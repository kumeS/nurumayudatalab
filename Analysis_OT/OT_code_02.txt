以下のサンプルコードは、

1. 10 時点それぞれで 100 点の 2 次元乱数データを生成
2. 各時点で最適なクラスタ数をシルエット解析で自動決定
3. k-means でクラスタリングし、クラスタごとの重心と質量（クラスタサイズ割合）を算出
4. 連続する時点間で重心＋質量を使って最適輸送計画を解く
5. `gganimate` で散布図と輸送矢印を時間軸に沿って動的に可視化

を行う一連の流れを示したものです。適宜ご自身のデータやパラメータに合わせて調整してください。

```r
#── 必要パッケージのインストール＆読み込み ──
pkgs <- c("cluster", "transport", "ggplot2", "gganimate", "dplyr")
for(p in pkgs) if(!requireNamespace(p, quietly=TRUE)) install.packages(p)
library(cluster)
library(transport)
library(ggplot2)
library(gganimate)
library(dplyr)

set.seed(123)

#── パラメータ設定 ──
n_points <- 100    # 各時点の点数
n_times  <- 10     # 時点数
max_k    <- 10     # クラスタ数候補の上限

#── シルエット幅で最適クラスタ数を決める関数 ──
choose_k <- function(mat, max_k=10){
  # 2..max_k で k-means → silhouette 平均幅を算出 → 最大となる k を返す
  sil <- sapply(2:max_k, function(k){
    km <- kmeans(mat, centers=k, nstart=10)
    ss <- silhouette(km$cluster, dist(mat))
    mean(ss[, 3])
  })
  which.max(sil) + 1
}

#── データ構造の準備 ──
all_clusters <- list()
all_centroids <- list()
all_weights   <- list()

#── 1) 各時点で乱数データ生成＋クラスタリング ──
for(t in seq_len(n_times)){
  # 例として、時間とともに中心が少し変化する乱数を作成
  mu <- c( sin(t/2), cos(t/3) ) * 2
  pts <- matrix(rnorm(n_points*2, sd=1), ncol=2) + matrix(mu, nrow=n_points, ncol=2, byrow=TRUE)
  
  # 最適 k の決定
  best_k <- choose_k(pts, max_k)
  
  # k-means
  km <- kmeans(pts, centers=best_k, nstart=20)
  
  # 結果を格納
  df_pts <- data.frame(time=t, x=pts[,1], y=pts[,2], cluster=km$cluster)
  all_clusters[[t]] <- df_pts
  
  # クラスタ重心と質量
  ctrs <- aggregate(cbind(x,y) ~ cluster, df_pts, mean) %>%
          mutate(time=t)
  wts <- as.data.frame(table(km$cluster)) %>%
         rename(cluster=Var1, size=Freq) %>%
         mutate(cluster=as.integer(as.character(cluster)),
                weight=size/sum(size),
                time=t)
  
  all_centroids[[t]] <- ctrs
  all_weights[[t]]   <- wts
}

# データを一つのデータフレームにまとめる
df_points    <- bind_rows(all_clusters)
df_centroids <- bind_rows(all_centroids)
df_weights   <- bind_rows(all_weights)

#── 2) 時点間で輸送プランを計算 ──
arrow_list <- list()
for(t in seq_len(n_times-1)){
  # この時点と次の時点の重心・質量行列
  C1 <- df_centroids %>% filter(time==t)   %>% arrange(cluster)
  C2 <- df_centroids %>% filter(time==t+1) %>% arrange(cluster)
  w1 <- df_weights   %>% filter(time==t)   %>% arrange(cluster) %>% pull(weight)
  w2 <- df_weights   %>% filter(time==t+1) %>% arrange(cluster) %>% pull(weight)
  
  # コスト行列（Euclid 距離）
  costm <- as.matrix(dist(rbind(C1[,c("x","y")], C2[,c("x","y")])))
  n1 <- nrow(C1)
  costm <- costm[1:n1, (n1+1):(n1+nrow(C2))]
  
  # 輸送プラン
  plan <- transport(a=w1, b=w2, costm=costm, method="shortsimplex")
  # plan は from, to, mass を返す
  
  # 矢印用に座標を結合
  df_arrows <- data.frame(
    time   = t,
    x      = C1$x[plan$from],
    y      = C1$y[plan$from],
    xend   = C2$x[plan$to],
    yend   = C2$y[plan$to],
    mass   = plan$mass
  )
  arrow_list[[t]] <- df_arrows
}
df_arrows <- bind_rows(arrow_list)

#── 3) 動的可視化 (gganimate) ──
p <- ggplot() +
  # 点
  geom_point(data=df_points,
             aes(x=x, y=y, color=factor(cluster)),
             alpha=0.6, size=1.5) +
  # クラスタ重心
  geom_point(data=df_centroids,
             aes(x=x, y=y),
             shape=4, size=3, stroke=1.2, color="black") +
  # 輸送矢印
  geom_segment(data=df_arrows,
               aes(x=x, y=y, xend=xend, yend=yend, size=mass),
               arrow = arrow(length = unit(0.1, "cm")),
               color="gray40", alpha=0.7) +
  scale_size_continuous(range=c(0.5, 2), guide="none") +
  labs(title = "Time: {frame_time}",
       subtitle = "クラスタ数自動決定＆最適輸送プラン",
       x = "X", y = "Y", color = "Cluster") +
  theme_minimal() +
  transition_time(time) +
  ease_aes("linear")

# アニメーション作成／再生
animate(p, nframes = n_times, fps = 2, width=600, height=600)

# 必要ならGIFやMP4で保存
# anim_save("dynamic_ot.gif", animation = last_animation())
```

---

### 説明ポイント

* **乱数生成**
  時間とともに中心がゆるやかに動くように `mu <- c(sin(t/2), cos(t/3))*2` を加算しています。
* **最適クラスタ数**
  2～`max_k` の各 k で k-means＋シルエット平均幅を評価し、最も高い k を自動選択。
* **輸送プラン**
  クラスタ重心とクラスタサイズに基づく離散分布同士で OT を解いています。
* **可視化**

  * 生データ点は色分けされたクラスタで散布
  * 重心は × マーク
  * 矢印の太さは輸送量（`mass`）を反映
  * `gganimate::transition_time()` で時間ごとにフレームを切り替え

この流れを参考に、実データの形態学的点群や時間経過データに応用してみてください。


以下のように `ggplot2::stat_density_2d()` を使って、各時点の散布図の背後に２次元密度マップを重ねることができます。`gganimate` のフレーム切り替えと組み合わせれば、時間ごとに動的に密度マップと輸送矢印を表示できます。

```r
#── 必要パッケージの読み込み ──
library(cluster)
library(transport)
library(ggplot2)
library(gganimate)
library(dplyr)

set.seed(123)
n_points <- 100
n_times  <- 10
max_k    <- 10

# （前段：乱数生成→クラスタリング→OTプラン計算まで）
# … ここは先ほどの all_clusters, df_centroids, df_weights, df_arrows が
#     既に作られているものとします …

#── 動的可視化 with 密度マップ ──
p_den <- ggplot() +
  # 1) 密度マップを背後に
  stat_density_2d(
    data = df_points,
    aes(x = x, y = y, fill = ..level..),
    geom    = "polygon",
    contour = TRUE,
    alpha   = 0.3
  ) +
  scale_fill_viridis_c(option = "A", guide = "none") +
  # 2) 生データ点
  geom_point(
    data = df_points,
    aes(x = x, y = y, color = factor(cluster)),
    alpha = 0.6, size = 1.5
  ) +
  # 3) クラスタ重心
  geom_point(
    data  = df_centroids,
    aes(x = x, y = y),
    shape = 4, size = 3, stroke = 1.2, color = "black"
  ) +
  # 4) OT 矢印
  geom_segment(
    data = df_arrows,
    aes(x = x,  y = y, 
        xend = xend, yend = yend, 
        size = mass),
    arrow = arrow(length = unit(0.1, "cm")),
    color = "gray40", alpha = 0.7
  ) +
  scale_size_continuous(range = c(0.5, 2), guide = "none") +
  labs(title    = "Time: {frame_time}",
       subtitle = "2D Density + OT Plan",
       x        = "X", y = "Y", color = "Cluster") +
  theme_minimal(base_size = 15) +
  transition_time(time) +
  ease_aes("linear")

# アニメーション作成
anim <- animate(p_den, nframes = n_times, fps = 2, width = 600, height = 600)

# GIFとして保存する場合
# anim_save("density_ot_animation.gif", anim)
```

### ポイント解説

* **`stat_density_2d(..., geom="polygon")`**
  各フレーム（`time`）ごとの点集合から 2D カーネル密度推定を行い、等高線に沿った塗りつぶし多角形を描画します。
* **`transition_time(time)`**
  `df_points`, `df_centroids`, `df_arrows` のいずれも `time` 列を持っていれば、自動的に時点ごとにデータを絞って再描画します。
* **重ね順**
  先に密度マップ、次に点・重心・矢印の順で描くことで、密度を背景にしつつマッチングの矢印を視認しやすくしています。
* **色・透過**
  密度マップには透過 (`alpha=0.3`)、クラスタ点は半透明、矢印はグレーにして重ね合わせても情報が埋もれないよう調整しています。

この流れを応用すれば、実データの時系列ペンギン形態点群に対しても、同様に２次元密度マップ＋最適輸送計画を動的に可視化できます。ぜひお試しください！


