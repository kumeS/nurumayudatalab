# ファイルアップロード時の自動ダウンロードバグ - 調査・修正レポート

## 発生日時
2025-11-30

## 症状
XLSXファイルをアップロードすると、ファイルが自動的にブラウザでダウンロードされる

## 根本原因（3つ）

### 1. 重複イベントリスナー
- `app-state-core.js:178` と `app-file-input.js:5-7` で同じクリックイベントが重複登録
- ファイル選択ダイアログが2回開かれる可能性

### 2. グローバルpreventDefaultの過剰適用
- `preventDefaultDragBehavior`関数がupload-zone内でも`dropEffect='copy'`を設定
- この設定がブラウザのデフォルト動作（ダウンロード）をトリガー

### 3. イベント伝播の制御不足
- dropZoneのイベントハンドラーで`stopPropagation()`が不足
- グローバルリスナーとの競合が発生

## 解決方法

### 修正1: preventDefaultDragBehavior関数の改善 (app-state-core.js:327-332)
```javascript
function preventDefaultDragBehavior(event) {
  if (!event) return;

  // upload-zone内では何もしない → ブラウザのデフォルト動作を許可
  if (event.target.closest && event.target.closest('.upload-zone')) {
    return;
  }

  // upload-zone外でのみpreventDefault
  event.preventDefault();
  event.stopPropagation();

  // dropEffect='none'でダウンロードを完全阻止
  if (event.dataTransfer && event.type !== 'dragleave') {
    event.dataTransfer.dropEffect = 'none';
    event.dataTransfer.effectAllowed = 'none';
  }
}
```

### 修正2: 重複イベントリスナーの削除 (app-file-input.js)
```javascript
// DISABLED: 重複防止のためコメントアウト
// (function(){
//   const dropZone = document.getElementById('dropZone');
//   const fileInput = document.getElementById('fileInput');
//   if (dropZone && fileInput) {
//     dropZone.addEventListener('click', () => {
//       fileInput.click();
//     });
//   }
// })();
```

### 修正3: dropZoneイベントハンドラーの改善 (app-state-core.js:201-210)
```javascript
dropZone.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();  // 追加: イベント伝播を防止
  dropZone.classList.remove('dragover');

  // ファイルのみ処理
  if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
    handleFiles(e.dataTransfer.files);
  }
});
```

### 修正4: グローバルリスナーにキャプチャフェーズ追加 (app-state-core.js:176)
```javascript
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  window.addEventListener(eventName, preventDefaultDragBehavior, true); // capture phase
});
```

## 検証結果
✅ FT6705-00013.xlsxのアップロード成功
✅ 自動ダウンロード発生せず
✅ 商品データ正常表示（17種類、393個）

---

## MCPでのファイルアップロード検証方法

### 1. Playwright MCPの使用

#### 基本構文
```javascript
mcp__playwright__upload_file
```

#### パラメータ
- `uid`: ページスナップショットから取得した要素のuid
- `filePath`: アップロードするファイルの絶対パス

#### 注意点
⚠️ **upload_fileツールの制限:**
- file input要素を直接クリックできる場合のみ動作
- 複雑なUI（カスタムアップロードエリア等）では失敗する可能性

### 2. 代替方法: evaluate_scriptの使用

#### 推奨アプローチ
```javascript
mcp__chrome-devtools__evaluate_script
{
  "function": "() => {
    const dropZone = document.getElementById('dropZone');
    if (dropZone) {
      dropZone.click();
      return 'Clicked on dropZone';
    }
    return 'dropZone not found';
  }"
}
```

#### メリット
- より柔軟な操作が可能
- カスタムUIでも対応可能
- エラーハンドリングが容易

### 3. 実際の検証フロー

```javascript
// 1. ページに移動
mcp__chrome-devtools__navigate_page({ url: "file://..." })

// 2. スナップショット取得
mcp__chrome-devtools__take_snapshot()

// 3. アップロードエリアをクリック（evaluate_script推奨）
mcp__chrome-devtools__evaluate_script({
  function: "() => { document.getElementById('dropZone').click(); return 'OK'; }"
})

// 4. コンソールログ確認
mcp__chrome-devtools__list_console_messages()

// 5. 結果のスナップショット取得
mcp__chrome-devtools__take_snapshot()
```

## 教訓

### Do（推奨）
✅ upload-zone内外で異なるイベントハンドリング
✅ stopPropagation()で イベント伝播を制御
✅ dropEffect='none'でupload-zone外のドロップを完全阻止
✅ キャプチャフェーズでグローバルリスナーを早期実行

### Don't（非推奨）
❌ 全イベントで一律preventDefault()を実行
❌ イベントリスナーの重複登録
❌ dropEffect='copy'をupload-zone内で設定
❌ グローバルとローカルのイベントハンドラー競合を放置

## 修正ファイル一覧
- js/app-state-core.js
- js/app-file-input.js
- js/app-state-extra.js
- js/app-helpers.js
- js/app-render.js

## 参考リンク
- MDN: DataTransfer.dropEffect https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/dropEffect
- MDN: Event.stopPropagation() https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation

---

# サマリー表示レイアウトの不具合とロールバック - 調査・修正レポート

## 発生日時
2025-11-30

## 症状
「ファイル別集計」タブにおいて、新しいパネル型（カード型）レイアウトを採用したところ、右端の情報（画像やボタンなど）が見切れて表示される問題が発生。CSS GridやFlexboxでの調整を試みたが、レスポンシブ対応と情報密度の両立が困難であった。

## 根本原因
1. **レイアウトの適合性**: 多列データ（ファイル名、画像群、日付、数量、金額など）を表示するには、カード型レイアウトよりもテーブル型レイアウトの方が適していた。
2. **CSS Gridの複雑化**: 画像サムネイルのグリッド（10列）と親コンテナのグリッドが競合し、`overflow`の制御が複雑化した。

## 解決方法
ユーザーの要望に基づき、旧バージョン（`webtool-ec-order-cilel-old`）のテーブル構造にロールバックを実施。

### 修正1: レンダリングロジックの復元 (js/app-render.js)
- `renderSummaryContent` 関数を書き換え、`div.summary-panel` の生成をやめ、`table.summary-table` を生成するように変更。
- カラム構成を「ファイル名」「商品画像」「注文日」「商品種類」「発注数量」「出荷数量」「小計」に戻した。

### 修正2: スタイルの復元 (style.css)
- `.summary-panel` 関連のCSS（Grid/Flexレイアウト用）を削除。
- 旧バージョンの `.summary-table` 関連のCSSを移植・適用。

## 教訓
- **データ密度とレイアウト**: 比較や一覧性が重要なデータ（集計表など）においては、モダンなカードUIよりも伝統的なテーブルUIの方が優れている場合が多い。
- **ロールバックの判断**: レイアウト調整に時間がかかりすぎる場合、安定していた旧仕様に戻す判断も重要。

## 修正ファイル一覧
- js/app-render.js
- style.css

---

# ファイル削除ボタンが機能しないバグ - 調査・修正レポート

## 発生日時
2025-11-30

## 症状
タブ上の「✕」ボタン（ファイル削除ボタン）をクリックしても、削除確認ダイアログが表示されず、何も起こらない（あるいはタブ切り替えが発生してしまう）。

## 根本原因
イベントハンドラ内でのDOM要素取得と条件判定の記述順序、および変数スコープの扱いにおいて、冗長かつ不安定な実装となっていた。

### 問題のコード（修正前）
```javascript
if (event.target.closest('.tab-close')) {
  event.preventDefault();
  event.stopPropagation();
  const deleteBtn = event.target.closest('.tab-close'); // 2回目の取得
  // ...
}
```
`closest`メソッドを条件式内で呼び出し、その直後に変数代入のために再度呼び出していた。論理的には動作するはずだが、DOM探索のコストが無駄にかかる上、コードの意図が不明瞭であった。また、何らかの要因でイベントターゲットの参照が不安定になった場合に正しく動作しないリスクがあった。

## 解決方法
DOM要素の取得を変数宣言として最初に行い、その変数の存在チェックを行う形にリファクタリングした。

### 修正コード（修正後）
```javascript
const deleteBtn = event.target.closest('.tab-close'); // 最初に取得
if (deleteBtn) {
  event.preventDefault();
  event.stopPropagation();
  // deleteBtn をそのまま使用
  const fileName = decodeTabValue(deleteBtn.dataset.file);
  // ...
}
```

## 教訓
- **DOM探索の効率化**: 同一のDOM要素探索（`closest`や`querySelector`）を複数回行うのは避け、一度変数に格納して再利用すべきである。
- **可読性と堅牢性**: 「取得してから判定する」というパターンを徹底することで、予期せぬバグを防ぎ、コードの意図を明確にできる。

## 修正ファイル一覧
- js/app-state-extra.js


---

# ファイル削除ボタンが機能しないバグ（ローカル環境対応） - 調査・修正レポート

## 発生日時
2025-11-30

## 症状
タブ上の「✕」ボタン（ファイル削除ボタン）をクリックしても、削除確認ダイアログが表示されず、何も起こらない（あるいはタブ切り替えが発生してしまう）。

## 根本原因
1. **イベントハンドラの複雑化**: `useCapture: true`（キャプチャフェーズ）でのイベント登録や、`stopImmediatePropagation()` の使用が、逆にイベントの正常な発火を妨げていた。
2. **CSSによる干渉**: `.tab-close` に対する `pointer-events: auto` や `z-index` の指定が、親要素のイベントハンドリングと競合していた可能性がある。
3. **ローカル環境でのIndexedDB制限**: ローカルファイル（`file://`）として実行した際、ブラウザのセキュリティポリシーにより `IndexedDB` へのアクセスが拒否され、エラーが発生して処理が中断していた。

## 解決方法

### 修正1: イベントハンドリングの単純化 (js/app-state-extra.js)
- `useCapture: true` を削除し、通常のバブリングフェーズでのイベント登録に戻した。
- `stopImmediatePropagation()` を削除し、`stopPropagation()` のみに変更。
- DOM要素の取得ロジックを整理。

### 修正2: CSSの単純化 (style.css)
- `.tab-close` のスタイル定義を、動作実績のある旧バージョンのシンプルな記述に戻した（不要な `z-index` 等の削除）。

### 修正3: エラーハンドリングの強化 (js/app-state-extra.js, js/app-state-core.js)
- `removeFile` 関数内で `deleteDataFromDB` 呼び出しを `try-catch` ブロックで囲み、DB削除に失敗しても画面上の削除処理を続行するように変更。
- `initDB` 関数内で `window.indexedDB` の存在チェックを追加し、非対応環境でも動作するように修正。

## 教訓
- **KISSの原則 (Keep It Simple, Stupid)**: イベントハンドリングやCSSは、必要以上に複雑にせず、シンプルに保つことがバグ回避につながる。
- **環境依存の考慮**: Webアプリをローカルファイルとして実行する場合、セキュリティ制約（IndexedDB, CORS等）が異なることに留意し、適切なエラーハンドリングを行う必要がある。
- **比較デバッグの有効性**: 動作する過去のバージョンとの比較は、原因特定において極めて有効である。

## 修正ファイル一覧
- js/app-state-extra.js
- js/app-state-core.js
- style.css

---

## ブラウザ互換性に関する追加報告 (2025-11-30)

### 動作状況
- **Google Chrome**: 正常に動作することを確認（修正適用後）。
- **ChatGPT Atlas**: 「✕」ボタンが機能しない現象が継続。

### 推測される原因 (ChatGPT Atlas環境)
1. **`confirm()` ダイアログの非互換性**:
   一部の組み込みブラウザやAIツール内のブラウザでは、`window.confirm()` がブロックされるか、UIが表示されずに `false` を返す場合がある。現在の実装は `if (confirm(...))` に依存しているため、ここで処理が止まっている可能性が高い。
   
2. **イベントハンドリングの差異**:
   タッチイベントやポインターイベントの扱いが標準ブラウザと異なり、クリックイベントとして正しく認識されていない可能性がある。

### 推奨される対策
- **ネイティブダイアログの廃止**: `window.confirm()` を使用せず、HTML/CSSによる独自のモーダルダイアログ（カスタムUI）を実装して削除確認を行う。これによりブラウザ依存を排除できる。

