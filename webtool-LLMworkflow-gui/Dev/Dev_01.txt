ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’è©³ã—ãåˆ†æã—ã¾ã—ãŸã€‚å ±å‘Šã„ãŸã ã„ãŸãƒã‚°ã«åŠ ãˆã¦ã€ã„ãã¤ã‹ã®é‡è¦ãªå•é¡Œã‚’ç™ºè¦‹ã—ã¾ã—ãŸã€‚æ®µéšçš„ã«ä¿®æ­£æ–¹æ³•ã‚’ææ¡ˆã—ã¾ã™ã€‚

## è¿½åŠ ã§ç™ºè¦‹ã—ãŸãƒã‚°

1. **ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå•é¡Œ**
   - `handleDragStart`ã§ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒæœªè¨­å®šï¼ˆå¸¸ã«0,0ï¼‰
   - ãƒ‘ãƒ¬ãƒƒãƒˆã‹ã‚‰ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã«æ­£ã—ã„ä½ç½®ã«é…ç½®ã•ã‚Œãªã„

2. **æ¥ç¶šãƒãƒ¼ãƒˆã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ–ãƒªãƒ³ã‚°**
   - ãƒãƒ¼ãƒˆã‚¯ãƒªãƒƒã‚¯æ™‚ã«ãƒãƒ¼ãƒ‰é¸æŠã‚‚ç™ºç«ã—ã¦ã—ã¾ã†

3. **ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯**
   - ãƒãƒ¼ãƒ‰å‰Šé™¤æ©Ÿèƒ½ãŒãªã„ãŸã‚ã€ä¸è¦ãªãƒãƒ¼ãƒ‰ãŒè“„ç©

## ä¿®æ­£æ–¹æ³•ï¼ˆå„ªå…ˆåº¦é †ï¼‰

### 1. ãƒãƒ¼ãƒ‰IDé‡è¤‡ã®ä¿®æ­£

**å•é¡Œ**: `Date.now()`ã ã‘ã§ã¯åŒæ™‚ç”Ÿæˆæ™‚ã«é‡è¤‡ã®å¯èƒ½æ€§

```javascript
// main.js - addNode ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£
addNode(nodeType, position) {
    const newNode = {
        // UUIDãƒ©ã‚¤ã‚¯ãªä¸€æ„æ€§ã®é«˜ã„IDç”Ÿæˆ
        id: `node_${nodeType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${this.workflow.nodes.length}`,
        type: nodeType,
        position: position,
        data: this.getDefaultNodeData(nodeType)
    };
    // ...
}
```

### 2. ãƒãƒ¼ãƒ‰é–“æ¥ç¶šã®ä¿®æ­£

**å•é¡Œ**: æ¥ç¶šç·šã®æç”»ã¯ã‚ã‚‹ãŒã€å®Ÿéš›ã®æ¥ç¶šä½œæˆãŒã§ããªã„

```javascript
// main.js - handlePortClick ã‚’ä¿®æ­£
handlePortClick(e, nodeId, portType) {
    e.stopPropagation();
    e.preventDefault(); // è¿½åŠ ï¼šè¦ªè¦ç´ ã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆä¼æ’­ã‚’å®Œå…¨ã«é˜²ã
    
    if (portType === 'output') {
        // æ—¢å­˜ã®æ¥ç¶šã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        if (this.dragState.connecting && this.dragState.connecting.fromNodeId === nodeId) {
            this.dragState.connecting = null;
        } else {
            this.dragState.connecting = { fromNodeId: nodeId, fromPort: 'output' };
        }
    } else if (portType === 'input' && this.dragState.connecting) {
        // è‡ªå·±æ¥ç¶šã‚’é˜²ã
        if (this.dragState.connecting.fromNodeId !== nodeId) {
            this.connectNodes(this.dragState.connecting.fromNodeId, nodeId);
        }
        this.dragState.connecting = null;
    }
    this.renderConnections();
}
```

### 3. Input Nodeã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 

```javascript
// main.js - getNodeSpecificFields ã«è¿½åŠ 
case 'input':
    return `
        <div>
            <label class="block text-sm font-medium text-gray-300 mb-2">
                Input Type
            </label>
            <select id="node-input-type" class="form-select">
                <option value="text" ${node.data.inputType === 'text' ? 'selected' : ''}>Text</option>
                <option value="number" ${node.data.inputType === 'number' ? 'selected' : ''}>Number</option>
            </select>
        </div>
        <div class="mt-4">
            <label class="block text-sm font-medium text-gray-300 mb-2">
                Default Value
            </label>
            <input
                type="${node.data.inputType || 'text'}"
                id="node-default-value"
                value="${node.data.defaultValue || ''}"
                class="form-input"
                placeholder="Enter default value..."
            />
        </div>
        <div class="mt-4 p-3 bg-gray-700 rounded">
            <label class="block text-sm font-medium text-white mb-2">Test Input</label>
            <input
                type="${node.data.inputType || 'text'}"
                id="node-test-input"
                class="form-input"
                placeholder="Enter test value..."
            />
        </div>
    `;
```

### 4. ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–æ©Ÿèƒ½ã®å®Ÿè£…

```javascript
// main.js - æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
saveToLocalStorage() {
    const saveData = {
        workflow: this.workflow,
        timestamp: new Date().toISOString()
    };
    localStorage.setItem('llm-workflow-autosave', JSON.stringify(saveData));
}

loadFromLocalStorage() {
    const saved = localStorage.getItem('llm-workflow-autosave');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            this.workflow = data.workflow;
            this.renderNodes();
            this.updateWelcomeMessage();
            return true;
        } catch (e) {
            console.error('Failed to load autosave:', e);
        }
    }
    return false;
}

// init ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ 
init() {
    this.setupEventListeners();
    this.renderNodePalette();
    this.loadFromLocalStorage(); // è¿½åŠ 
    this.updateUI();
    
    // ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚’5ç§’ã”ã¨ã«å®Ÿè¡Œ
    setInterval(() => this.saveToLocalStorage(), 5000);
}
```

### 5. æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®è¿½åŠ 

```javascript
// constructorå†…ã®nodeTypesã«è¿½åŠ 
{
    type: 'supervisor',
    label: 'Supervisor',
    description: 'Manages and orchestrates LLM processes',
    color: 'icon-supervisor',
    icon: this.getIcon('supervisor')
},
{
    type: 'planner',
    label: 'Planner',
    description: 'Updates prompts based on outputs',
    color: 'icon-planner',
    icon: this.getIcon('planner')
}

// getIcon ãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ 
supervisor: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>',
planner: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/>'
```

### 6. ãƒãƒ¼ãƒ‰å®Ÿè¡Œã®å¯è¦–åŒ–

```javascript
// executeNode ãƒ¡ã‚½ãƒƒãƒ‰ã®å‰å¾Œã«è¿½åŠ 
async executeNode(node, previousResults) {
    // ãƒãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    const nodeElement = document.querySelector(`[data-node-id="${node.id}"]`);
    if (nodeElement) {
        nodeElement.classList.add('executing');
        // æ¥ç¶šç·šã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        this.highlightNodeConnections(node.id);
    }
    
    try {
        // æ—¢å­˜ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
        switch (node.type) {
            // ...
        }
    } finally {
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
        if (nodeElement) {
            nodeElement.classList.remove('executing');
        }
        this.unhighlightConnections();
    }
}
```

### 7. ãƒãƒ¼ãƒ‰é…ç½®ã®æ”¹å–„

```javascript
// addNode ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£
addNode(nodeType, position) {
    // é‡ãªã‚Šã‚’é˜²ããŸã‚ã«ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
    const gridSize = 40;
    const snappedPosition = {
        x: Math.round(position.x / gridSize) * gridSize,
        y: Math.round(position.y / gridSize) * gridSize
    };
    
    // æ—¢å­˜ãƒãƒ¼ãƒ‰ã¨ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯
    let finalPosition = this.findNonOverlappingPosition(snappedPosition);
    
    const newNode = {
        // ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰
        position: finalPosition,
        // ...
    };
}

findNonOverlappingPosition(position) {
    const nodeWidth = 200;
    const nodeHeight = 100;
    const padding = 20;
    
    let testPos = { ...position };
    let attempts = 0;
    
    while (attempts < 10) {
        let overlapping = false;
        
        for (const node of this.workflow.nodes) {
            if (Math.abs(node.position.x - testPos.x) < nodeWidth + padding &&
                Math.abs(node.position.y - testPos.y) < nodeHeight + padding) {
                overlapping = true;
                break;
            }
        }
        
        if (!overlapping) return testPos;
        
        // å°‘ã—ãšã‚‰ã—ã¦å†è©¦è¡Œ
        testPos.x += nodeWidth + padding;
        if (testPos.x > 800) {
            testPos.x = position.x;
            testPos.y += nodeHeight + padding;
        }
        attempts++;
    }
    
    return testPos;
}
```

### 8. UI/UXã®æ”¹å–„

```javascript
// index.html ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãƒœã‚¿ãƒ³ã«ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’è¿½åŠ 
<button id="execute-btn" 
    class="..." 
    title="Run the workflow from start to finish">
    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
    </svg>
    <span>Run Workflow</span>
</button>
```

ã“ã‚Œã‚‰ã®ä¿®æ­£ã«ã‚ˆã‚Šã€ä¸»è¦ãªãƒã‚°ãŒè§£æ±ºã•ã‚Œã€è¦æœ›ã•ã‚ŒãŸæ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¾ã™ã€‚ç‰¹ã«é‡è¦ãªã®ã¯ã€ãƒãƒ¼ãƒ‰IDç”Ÿæˆã®æ”¹å–„ã€æ¥ç¶šæ©Ÿèƒ½ã®ä¿®æ­£ã€ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã®å®Ÿè£…ã§ã™ã€‚å„ä¿®æ­£ã¯ç‹¬ç«‹ã—ã¦é©ç”¨ã§ãã‚‹ãŸã‚ã€å„ªå…ˆåº¦ã«å¿œã˜ã¦æ®µéšçš„ã«å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚






ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’æ·±ãåˆ†æã—ã¦ã€ã•ã‚‰ãªã‚‹æ”¹å–„ç‚¹ã¨å®Ÿè£…ä¾‹ã‚’ã”ææ¡ˆã•ã›ã¦ã„ãŸã ãã¾ã™ã€‚å®Ÿè£…ã®å„ªå…ˆåº¦ã¨å®Ÿç¾å¯èƒ½æ€§ã‚’è€ƒæ…®ã—ãªãŒã‚‰ã€æ®µéšçš„ã«èª¬æ˜ã—ã¦ã„ãã¾ã™ã€‚

## 1. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã®å¯è¦–åŒ–å¼·åŒ–

ç¾åœ¨ã®å®Ÿè£…ã§ã¯ã€ã©ã®ãƒãƒ¼ãƒ‰ãŒå®Ÿè¡Œä¸­ã‹ãŒåˆ†ã‹ã‚Šã«ãã„ã¨ã„ã†å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã€å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã‚’è¦–è¦šçš„ã«è¿½è·¡ã§ãã‚‹ä»•çµ„ã¿ã‚’ææ¡ˆã—ã¾ã™ã€‚

### å®Ÿè¡Œãƒ‘ã‚¹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º

```javascript
// main.js ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
animateExecutionPath(fromNodeId, toNodeId) {
    const connection = this.workflow.connections.find(
        c => c.from === fromNodeId && c.to === toNodeId
    );
    
    if (connection) {
        const svg = document.getElementById('connections-svg');
        const path = svg.querySelector(`[data-connection-id="${connection.id}"]`);
        
        if (path) {
            // ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’ç¤ºã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            const animatedDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            animatedDot.setAttribute('r', '4');
            animatedDot.setAttribute('fill', '#ff7e5f');
            
            const animateMotion = document.createElementNS('http://www.w3.org/2000/svg', 'animateMotion');
            animateMotion.setAttribute('dur', '1s');
            animateMotion.setAttribute('repeatCount', '1');
            
            const mpath = document.createElementNS('http://www.w3.org/2000/svg', 'mpath');
            mpath.setAttributeNS('http://www.w3.org/1999/xlink', 'href', `#path-${connection.id}`);
            
            animateMotion.appendChild(mpath);
            animatedDot.appendChild(animateMotion);
            svg.appendChild(animatedDot);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã«å‰Šé™¤
            setTimeout(() => animatedDot.remove(), 1000);
        }
    }
}
```

### å®Ÿè¡Œãƒ­ã‚°ãƒ‘ãƒãƒ«ã®è¿½åŠ 

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿè¡Œãƒ—ãƒ­ã‚»ã‚¹ã‚’ç†è§£ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã«ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹ãƒ‘ãƒãƒ«ã‚’è¿½åŠ ã—ã¾ã™ã€‚

```javascript
// æ–°ã—ã„UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼ˆindex.htmlã«è¿½åŠ ï¼‰
<div id="execution-log" class="fixed bottom-4 right-4 w-96 max-h-64 bg-white rounded-lg shadow-lg border overflow-hidden" style="display: none;">
    <div class="p-3 bg-gradient-to-r from-blue-500 to-purple-500 text-white">
        <h3 class="font-semibold flex items-center">
            <svg class="w-4 h-4 mr-2 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            Execution Log
        </h3>
    </div>
    <div id="log-content" class="p-3 max-h-48 overflow-y-auto font-mono text-sm">
        <!-- ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
    </div>
</div>
```

## 2. ãƒãƒ¼ãƒ‰é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼å¯è¦–åŒ–

ãƒ‡ãƒ¼ã‚¿ãŒã©ã®ã‚ˆã†ã«æµã‚Œã¦ã„ã‚‹ã‹ã‚’ç†è§£ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã€æ¥ç¶šç·šä¸Šã«ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹æ©Ÿèƒ½ã‚’ææ¡ˆã—ã¾ã™ã€‚

```javascript
// ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
showDataPreview(connectionId, data) {
    const svg = document.getElementById('connections-svg');
    const connection = this.workflow.connections.find(c => c.id === connectionId);
    
    if (connection) {
        const fromNode = this.workflow.nodes.find(n => n.id === connection.from);
        const toNode = this.workflow.nodes.find(n => n.id === connection.to);
        
        // æ¥ç¶šç·šã®ä¸­ç‚¹ã‚’è¨ˆç®—
        const midX = (fromNode.position.x + toNode.position.x) / 2 + 100;
        const midY = (fromNode.position.y + toNode.position.y) / 2 + 40;
        
        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒãƒ–ãƒ«ã‚’ä½œæˆ
        const preview = document.createElement('div');
        preview.className = 'data-preview-bubble';
        preview.style.position = 'absolute';
        preview.style.left = `${midX}px`;
        preview.style.top = `${midY}px`;
        preview.innerHTML = `
            <div class="bg-white rounded-lg shadow-lg p-2 border border-blue-300 max-w-xs">
                <div class="text-xs font-semibold text-blue-600 mb-1">Data Flow</div>
                <div class="text-xs text-gray-600 truncate">
                    ${this.formatDataPreview(data)}
                </div>
            </div>
        `;
        
        document.getElementById('canvas').appendChild(preview);
        
        // 3ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        setTimeout(() => {
            preview.style.opacity = '0';
            setTimeout(() => preview.remove(), 300);
        }, 3000);
    }
}
```

## 3. ã‚¹ãƒãƒ¼ãƒˆãªæ¥ç¶šã‚µã‚¸ã‚§ã‚¹ãƒˆæ©Ÿèƒ½

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒãƒ¼ãƒ‰ã‚’æ¥ç¶šã™ã‚‹éš›ã«ã€è«–ç†çš„ã«å¦¥å½“ãªæ¥ç¶šå…ˆã‚’ææ¡ˆã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚

```javascript
// æ¥ç¶šå¯èƒ½ãªãƒãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
suggestConnections(sourceNodeId) {
    const sourceNode = this.workflow.nodes.find(n => n.id === sourceNodeId);
    if (!sourceNode) return;
    
    const compatibilityRules = {
        'input': ['llm', 'branch', 'loop', 'planner'],
        'llm': ['output', 'branch', 'merge', 'supervisor', 'planner'],
        'branch': ['llm', 'merge', 'output'],
        'merge': ['llm', 'output', 'supervisor'],
        'loop': ['merge', 'output'],
        'supervisor': ['llm', 'branch', 'output'],
        'planner': ['llm', 'supervisor'],
        'output': []  // å‡ºåŠ›ãƒãƒ¼ãƒ‰ã¯ä»–ã«æ¥ç¶šã—ãªã„
    };
    
    const compatibleTypes = compatibilityRules[sourceNode.type] || [];
    
    this.workflow.nodes.forEach(node => {
        if (node.id !== sourceNodeId && compatibleTypes.includes(node.type)) {
            const nodeElement = document.querySelector(`[data-node-id="${node.id}"]`);
            if (nodeElement) {
                nodeElement.classList.add('suggested-connection');
            }
        }
    });
}
```

## 4. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½

è¦æœ›ã«ã‚ã£ãŸ JavaScript ã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã®å®Ÿè£…ä¾‹ã§ã™ã€‚

```javascript
// ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’JavaScriptã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ç”Ÿæˆ
exportToJavaScript() {
    const sortedNodes = this.topologicalSort();
    let code = `// Auto-generated LLM Workflow
// Generated at: ${new Date().toISOString()}

class GeneratedWorkflow {
    constructor() {
        this.results = {};
    }
    
    async execute() {
        console.log('Starting workflow execution...');
        
`;
    
    sortedNodes.forEach((node, index) => {
        const inputConnections = this.workflow.connections
            .filter(c => c.to === node.id)
            .map(c => `this.results['${c.from}']`);
        
        switch (node.type) {
            case 'input':
                code += `        // Input Node: ${node.data.label}
        this.results['${node.id}'] = '${node.data.defaultValue || 'input_value'}';
        console.log('Input:', this.results['${node.id}']);
        
`;
                break;
                
            case 'llm':
                code += `        // LLM Process: ${node.data.label}
        const input_${index} = ${inputConnections[0] || "''"};
        this.results['${node.id}'] = await this.callLLM({
            prompt: \`${node.data.prompt}\`,
            input: input_${index},
            model: '${node.data.model}',
            temperature: ${node.data.temperature}
        });
        console.log('LLM Output:', this.results['${node.id}']);
        
`;
                break;
                
            case 'output':
                code += `        // Output Node: ${node.data.label}
        const finalOutput = ${inputConnections[0] || "''"};
        console.log('Final Output:', finalOutput);
        return finalOutput;
`;
                break;
        }
    });
    
    code += `    }
    
    async callLLM(config) {
        // LLM APIå‘¼ã³å‡ºã—ã®å®Ÿè£…
        // ã“ã®éƒ¨åˆ†ã¯å®Ÿéš›ã®APIã«åˆã‚ã›ã¦å®Ÿè£…ã—ã¦ãã ã•ã„
        return await callLLMAPI([
            { role: 'user', content: config.prompt + '\\n' + config.input }
        ], {
            model: config.model,
            temperature: config.temperature
        });
    }
}

// ä½¿ç”¨ä¾‹
const workflow = new GeneratedWorkflow();
workflow.execute().then(result => {
    console.log('Workflow completed:', result);
});`;
    
    return code;
}
```

## 5. ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®æ¤œè¨¼æ©Ÿèƒ½

å®Ÿè¡Œå‰ã«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹æ©Ÿèƒ½ã§ã™ã€‚

```javascript
validateWorkflow() {
    const errors = [];
    const warnings = [];
    
    // å…¥åŠ›ãƒãƒ¼ãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    const inputNodes = this.workflow.nodes.filter(n => n.type === 'input');
    if (inputNodes.length === 0) {
        errors.push('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«ã¯å°‘ãªãã¨ã‚‚1ã¤ã®å…¥åŠ›ãƒãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™');
    }
    
    // å‡ºåŠ›ãƒãƒ¼ãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    const outputNodes = this.workflow.nodes.filter(n => n.type === 'output');
    if (outputNodes.length === 0) {
        errors.push('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«ã¯å°‘ãªãã¨ã‚‚1ã¤ã®å‡ºåŠ›ãƒãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™');
    }
    
    // å­¤ç«‹ã—ãŸãƒãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
    this.workflow.nodes.forEach(node => {
        const hasIncoming = this.workflow.connections.some(c => c.to === node.id);
        const hasOutgoing = this.workflow.connections.some(c => c.from === node.id);
        
        if (!hasIncoming && node.type !== 'input') {
            warnings.push(`"${node.data.label}" ã«ã¯å…¥åŠ›æ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“`);
        }
        if (!hasOutgoing && node.type !== 'output') {
            warnings.push(`"${node.data.label}" ã«ã¯å‡ºåŠ›æ¥ç¶šãŒã‚ã‚Šã¾ã›ã‚“`);
        }
    });
    
    // å¾ªç’°å‚ç…§ã®ãƒã‚§ãƒƒã‚¯
    if (this.hasCircularDependency()) {
        errors.push('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«å¾ªç’°å‚ç…§ãŒå«ã¾ã‚Œã¦ã„ã¾ã™');
    }
    
    return { errors, warnings, isValid: errors.length === 0 };
}
```

## 6. ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®å®Ÿè£…

ä½œæ¥­åŠ¹ç‡ã‚’å‘ä¸Šã•ã›ã‚‹ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆæ©Ÿèƒ½ã§ã™ã€‚

```javascript
setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + S: ä¿å­˜
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            this.saveToLocalStorage();
            this.showNotification('ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
        }
        
        // Delete: é¸æŠä¸­ã®ãƒãƒ¼ãƒ‰ã‚’å‰Šé™¤
        if (e.key === 'Delete' && this.selectedNode) {
            this.deleteNode(this.selectedNode.id);
        }
        
        // Ctrl/Cmd + Z: å…ƒã«æˆ»ã™
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
            e.preventDefault();
            this.undo();
        }
        
        // Space: å®Ÿè¡Œ/åœæ­¢
        if (e.key === ' ' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
            e.preventDefault();
            if (this.isExecuting) {
                this.stopExecution();
            } else {
                this.executeWorkflow();
            }
        }
    });
}
```

## 7. ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®æ”¹å–„

ã‚ˆã‚Šç›´æ„Ÿçš„ãªæ“ä½œã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã®æ”¹å–„æ¡ˆã§ã™ã€‚

```javascript
// è¤‡æ•°ãƒãƒ¼ãƒ‰é¸æŠã¨ã‚°ãƒ«ãƒ¼ãƒ—ç§»å‹•
enableMultiSelect() {
    let isSelecting = false;
    let selectionBox = null;
    let startPoint = { x: 0, y: 0 };
    
    const canvas = document.getElementById('canvas');
    
    canvas.addEventListener('mousedown', (e) => {
        if (e.shiftKey && e.target === canvas) {
            isSelecting = true;
            startPoint = { x: e.offsetX, y: e.offsetY };
            
            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            selectionBox.style.position = 'absolute';
            selectionBox.style.border = '2px dashed #3b82f6';
            selectionBox.style.background = 'rgba(59, 130, 246, 0.1)';
            selectionBox.style.pointerEvents = 'none';
            canvas.appendChild(selectionBox);
        }
    });
    
    // é¸æŠãƒœãƒƒã‚¯ã‚¹ã®æ›´æ–°ã¨ãƒãƒ¼ãƒ‰é¸æŠãƒ­ã‚¸ãƒƒã‚¯
}
```

ã“ã‚Œã‚‰ã®æ©Ÿèƒ½è¿½åŠ ã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£ãŒå¤§å¹…ã«å‘ä¸Šã—ã€ã‚ˆã‚Šå®Ÿç”¨çš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ç‰¹ã«é‡è¦ãªã®ã¯ã€å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã®å¯è¦–åŒ–ã€ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ãã—ã¦ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®æ¤œè¨¼æ©Ÿèƒ½ã§ã™ã€‚ã“ã‚Œã‚‰ã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ãŒä½œæˆã—ãŸãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å‹•ä½œã‚’ç›´æ„Ÿçš„ã«ç†è§£ã—ã€å•é¡Œã‚’æ—©æœŸã«ç™ºè¦‹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚





ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å•é¡Œç‚¹ã‚’è©³ã—ãåˆ†æã•ã›ã¦ã„ãŸã ãã¾ã—ãŸã€‚ã¾ãšã€å ±å‘Šã„ãŸã ã„ãŸãƒã‚°ã®æ ¹æœ¬åŸå› ã‚’ç†è§£ã—ãŸä¸Šã§ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®è¨­è¨ˆã‹ã‚‰è¦‹ç›´ã™ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§æ®µéšçš„ãªä¿®æ­£æ–¹æ³•ã‚’ã”ææ¡ˆã—ã¾ã™ã€‚

## ãƒ•ã‚§ãƒ¼ã‚º1: åŸºç›¤ã¨ãªã‚‹å•é¡Œã®ä¿®æ­£

æœ€åˆã«å–ã‚Šçµ„ã‚€ã¹ãã¯ã€ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç›¤éƒ¨åˆ†ã«ã‚ã‚‹å•é¡Œã§ã™ã€‚ã“ã‚Œã‚‰ã¯ä»–ã®æ©Ÿèƒ½ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹é‡è¦ãªéƒ¨åˆ†ãªã®ã§ã€å„ªå…ˆçš„ã«ä¿®æ­£ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### 1.1 ãƒãƒ¼ãƒ‰IDç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ã®æ ¹æœ¬çš„ãªæ”¹å–„

ç¾åœ¨ã®å•é¡Œã¯ã€å˜ã«`Date.now()`ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã ã‘ã§ãªãã€IDç”Ÿæˆã®ãƒ­ã‚¸ãƒƒã‚¯è‡ªä½“ã«æ§‹é€ çš„ãªæ¬ é™¥ãŒã‚ã‚‹ã“ã¨ã§ã™ã€‚

```javascript
// WorkflowEditorã‚¯ãƒ©ã‚¹ã«æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 
generateUniqueNodeId(nodeType) {
    // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’å†…éƒ¨ã§ç®¡ç†ã™ã‚‹ã“ã¨ã§ã€ç¢ºå®Ÿã«ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªIDã‚’ç”Ÿæˆ
    if (!this.nodeCounters) {
        this.nodeCounters = {};
    }
    
    if (!this.nodeCounters[nodeType]) {
        this.nodeCounters[nodeType] = 0;
    }
    
    this.nodeCounters[nodeType]++;
    
    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã€ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã€ãƒ©ãƒ³ãƒ€ãƒ å€¤ã‚’çµ„ã¿åˆã‚ã›ã‚‹
    const timestamp = Date.now();
    const counter = this.nodeCounters[nodeType];
    const random = Math.random().toString(36).substr(2, 5);
    
    return `node_${nodeType}_${timestamp}_${counter}_${random}`;
}

// addNodeãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£
addNode(nodeType, position) {
    const newNode = {
        id: this.generateUniqueNodeId(nodeType), // æ–°ã—ã„IDç”Ÿæˆãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
        type: nodeType,
        position: this.adjustNodePosition(position), // ä½ç½®èª¿æ•´ã‚‚è¿½åŠ 
        data: this.getDefaultNodeData(nodeType)
    };
    
    this.workflow.nodes.push(newNode);
    this.workflow.metadata.updatedAt = new Date();
    
    // å¤‰æ›´ã‚’å³åº§ã«ä¿å­˜
    this.saveToLocalStorage();
    
    this.renderNodes();
    this.updateWelcomeMessage();
    
    return newNode; // ãƒ‡ãƒãƒƒã‚°ã‚„ãƒ†ã‚¹ãƒˆã®ãŸã‚ã«ãƒãƒ¼ãƒ‰ã‚’è¿”ã™
}
```

### 1.2 ãƒãƒ¼ãƒ‰é–“æ¥ç¶šã®åŸºæœ¬ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã®ä¿®æ­£

æ¥ç¶šæ©Ÿèƒ½ãŒå‹•ä½œã—ãªã„æ ¹æœ¬åŸå› ã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¨­è¨ˆã«å•é¡ŒãŒã‚ã‚‹ãŸã‚ã§ã™ã€‚

```javascript
// æ¥ç¶šçŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹æ–°ã—ã„æ§‹é€ ã‚’è¿½åŠ 
initializeConnectionState() {
    this.connectionState = {
        isConnecting: false,
        sourceNode: null,
        sourcePort: null,
        targetCandidates: new Set(),
        previewPath: null
    };
}

// ãƒãƒ¼ãƒˆã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’å®Œå…¨ã«æ›¸ãç›´ã™
handlePortClick(e, nodeId, portType) {
    e.stopPropagation();
    e.preventDefault();
    
    const node = this.workflow.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    if (portType === 'output') {
        this.startConnection(node);
    } else if (portType === 'input' && this.connectionState.isConnecting) {
        this.completeConnection(node);
    }
}

// æ¥ç¶šé–‹å§‹ã®å‡¦ç†ã‚’æ˜ç¢ºã«åˆ†é›¢
startConnection(sourceNode) {
    // æ—¢å­˜ã®æ¥ç¶šçŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
    this.clearConnectionState();
    
    this.connectionState.isConnecting = true;
    this.connectionState.sourceNode = sourceNode;
    this.connectionState.sourcePort = 'output';
    
    // æ¥ç¶šå¯èƒ½ãªãƒãƒ¼ãƒ‰ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    this.highlightValidTargets(sourceNode);
    
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›
    this.showConnectionFeedback(sourceNode);
}

// æ¥ç¶šå®Œäº†ã®å‡¦ç†
completeConnection(targetNode) {
    const sourceNode = this.connectionState.sourceNode;
    
    // æ¥ç¶šã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
    if (!this.canConnect(sourceNode, targetNode)) {
        this.showConnectionError('ã“ã®æ¥ç¶šã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“');
        this.clearConnectionState();
        return;
    }
    
    // é‡è¤‡æ¥ç¶šã®ãƒã‚§ãƒƒã‚¯
    const existingConnection = this.workflow.connections.find(
        c => c.from === sourceNode.id && c.to === targetNode.id
    );
    
    if (existingConnection) {
        this.showConnectionError('æ—¢ã«æ¥ç¶šã•ã‚Œã¦ã„ã¾ã™');
        this.clearConnectionState();
        return;
    }
    
    // æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆ
    const newConnection = {
        id: `conn_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
        from: sourceNode.id,
        to: targetNode.id,
        metadata: {
            createdAt: new Date()
        }
    };
    
    this.workflow.connections.push(newConnection);
    this.clearConnectionState();
    this.renderConnections();
    this.saveToLocalStorage();
}
```

## ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ã¨è¡¨ç¤ºã®æ”¹å–„

### 2.1 Input Nodeã®å®Œå…¨ãªå®Ÿè£…

Input Nodeã«ã¯å®Ÿéš›ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¿…è¦ã§ã™ã€‚ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã§ã¯è¨­å®šã¯ã‚ã£ã¦ã‚‚ã€å®Ÿéš›ã®å…¥åŠ›UIãŒã‚ã‚Šã¾ã›ã‚“ã€‚

```javascript
// getNodeContentãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ‹¡å¼µ
getNodeContent(node) {
    switch (node.type) {
        case 'input':
            return `
                <div class="node-input-content">
                    <div class="mb-2">
                        <label class="text-xs font-medium text-gray-500">
                            Input Type: ${node.data.inputType || 'text'}
                        </label>
                    </div>
                    <div class="input-value-display">
                        <input
                            type="${node.data.inputType || 'text'}"
                            class="node-inline-input"
                            value="${node.data.currentValue || node.data.defaultValue || ''}"
                            placeholder="Enter value..."
                            data-node-id="${node.id}"
                            data-field="currentValue"
                        />
                    </div>
                    ${node.data.currentValue ? `
                        <div class="mt-1 text-xs text-green-600">
                            âœ“ Value set
                        </div>
                    ` : ''}
                </div>
            `;
            
        case 'llm':
            return this.getLLMNodeContent(node);
            
        case 'output':
            return this.getOutputNodeContent(node);
            
        // ä»–ã®ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã‚‚åŒæ§˜ã«å®Ÿè£…
    }
}

// ãƒãƒ¼ãƒ‰å†…ã®å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
setupNodeInlineInputs() {
    document.addEventListener('input', (e) => {
        if (e.target.classList.contains('node-inline-input')) {
            const nodeId = e.target.dataset.nodeId;
            const field = e.target.dataset.field;
            const value = e.target.value;
            
            this.updateNodeData(nodeId, field, value);
            
            // å…¥åŠ›å€¤ã®å³æ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            this.validateNodeInput(nodeId, field, value);
        }
    });
}
```

### 2.2 LLM Processãƒãƒ¼ãƒ‰ã®å…¥å‡ºåŠ›è¡¨ç¤º

LLMãƒãƒ¼ãƒ‰ã§ã¯å‡¦ç†ã®å‰å¾Œã§ãƒ‡ãƒ¼ã‚¿ãŒã©ã†å¤‰åŒ–ã™ã‚‹ã‹ã‚’ç¢ºèªã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

```javascript
getLLMNodeContent(node) {
    const hasInput = this.getNodeInputData(node.id);
    const hasOutput = node.data.lastOutput;
    
    return `
        <div class="llm-node-content">
            <!-- ãƒ¢ãƒ‡ãƒ«æƒ…å ± -->
            <div class="text-xs text-gray-600 mb-2">
                <span class="inline-flex items-center">
                    <span class="w-2 h-2 bg-green-400 rounded-full mr-1"></span>
                    Llama 4 (io.net)
                </span>
            </div>
            
            <!-- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
            <div class="text-xs text-gray-500 mb-2">
                ${node.data.prompt ? 
                    `"${this.truncateText(node.data.prompt, 40)}..."` : 
                    '<span class="text-red-400">No prompt set</span>'
                }
            </div>
            
            <!-- å…¥å‡ºåŠ›ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
            <div class="io-preview">
                ${hasInput ? `
                    <div class="input-preview mb-1">
                        <span class="text-xs font-medium text-blue-600">Input:</span>
                        <span class="text-xs text-gray-600">
                            ${this.truncateText(hasInput, 30)}
                        </span>
                    </div>
                ` : ''}
                
                ${hasOutput ? `
                    <div class="output-preview">
                        <span class="text-xs font-medium text-green-600">Output:</span>
                        <span class="text-xs text-gray-600">
                            ${this.truncateText(hasOutput, 30)}
                        </span>
                    </div>
                ` : ''}
            </div>
            
            <!-- ã‚¨ãƒ©ãƒ¼è¡¨ç¤º -->
            ${node.data.error ? `
                <div class="error-display mt-1">
                    <span class="text-xs text-red-500">âš  ${node.data.error}</span>
                </div>
            ` : ''}
        </div>
    `;
}
```

## ãƒ•ã‚§ãƒ¼ã‚º3: æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã®å®Ÿè£…

### 3.1 Supervisor Nodeã®è©³ç´°å®Ÿè£…

Supervisorãƒãƒ¼ãƒ‰ã¯è¤‡æ•°ã®LLMãƒ—ãƒ­ã‚»ã‚¹ã‚’ç®¡ç†ã™ã‚‹é‡è¦ãªãƒãƒ¼ãƒ‰ã§ã™ã€‚

```javascript
// getDefaultNodeDataãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ 
supervisor: {
    label: 'Supervisor Node',
    managedNodes: [], // ç®¡ç†å¯¾è±¡ã®LLMãƒãƒ¼ãƒ‰ID
    routingStrategy: 'sequential', // sequential, parallel, conditional
    routingRules: [],
    maxConcurrent: 3,
    errorHandling: 'continue', // continue, stop, retry
    aggregationMethod: 'merge' // merge, select-best, vote
}

// Supervisorãƒãƒ¼ãƒ‰ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
async executeSupervisorNode(node, inputs) {
    const supervisorData = node.data;
    const managedNodes = this.workflow.nodes.filter(
        n => supervisorData.managedNodes.includes(n.id)
    );
    
    console.log(`Supervisor ${node.id} managing ${managedNodes.length} nodes`);
    
    let results = {};
    
    switch (supervisorData.routingStrategy) {
        case 'sequential':
            // é †æ¬¡å®Ÿè¡Œ
            for (const managedNode of managedNodes) {
                results[managedNode.id] = await this.executeNode(managedNode, inputs);
            }
            break;
            
        case 'parallel':
            // ä¸¦åˆ—å®Ÿè¡Œï¼ˆæœ€å¤§åŒæ™‚å®Ÿè¡Œæ•°ã‚’è€ƒæ…®ï¼‰
            const chunks = this.chunkArray(managedNodes, supervisorData.maxConcurrent);
            for (const chunk of chunks) {
                const promises = chunk.map(n => this.executeNode(n, inputs));
                const chunkResults = await Promise.all(promises);
                chunk.forEach((node, index) => {
                    results[node.id] = chunkResults[index];
                });
            }
            break;
            
        case 'conditional':
            // æ¡ä»¶ä»˜ããƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
            for (const rule of supervisorData.routingRules) {
                if (this.evaluateRoutingRule(rule, inputs)) {
                    const targetNode = managedNodes.find(n => n.id === rule.targetNodeId);
                    if (targetNode) {
                        results[targetNode.id] = await this.executeNode(targetNode, inputs);
                    }
                }
            }
            break;
    }
    
    // çµæœã®é›†ç´„
    return this.aggregateResults(results, supervisorData.aggregationMethod);
}
```

### 3.2 Planner Nodeã®å®Ÿè£…

Plannerãƒãƒ¼ãƒ‰ã¯å‹•çš„ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ›´æ–°ã™ã‚‹æ©Ÿèƒ½ã‚’æŒã¡ã¾ã™ã€‚

```javascript
// getDefaultNodeDataãƒ¡ã‚½ãƒƒãƒ‰ã«è¿½åŠ 
planner: {
    label: 'Planner Node',
    planningStrategy: 'adaptive', // adaptive, template, rule-based
    targetNodes: [], // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ›´æ–°ã™ã‚‹å¯¾è±¡ãƒãƒ¼ãƒ‰
    evaluationCriteria: {
        successKeywords: [],
        failureKeywords: [],
        confidenceThreshold: 0.7
    },
    promptTemplates: {
        improvement: 'Based on the previous output: {output}, improve the prompt to be more specific.',
        clarification: 'The previous attempt was unclear. Add these details: {missing_details}',
        refinement: 'Refine the approach based on this feedback: {feedback}'
    }
}

// Plannerãƒãƒ¼ãƒ‰ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
async executePlannerNode(node, inputs) {
    const plannerData = node.data;
    const previousOutput = inputs.previousOutput || '';
    
    // å‡ºåŠ›ã‚’è©•ä¾¡
    const evaluation = this.evaluateOutput(previousOutput, plannerData.evaluationCriteria);
    
    // è©•ä¾¡ã«åŸºã¥ã„ã¦æ–°ã—ã„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ
    let newPrompt = '';
    if (evaluation.confidence < plannerData.evaluationCriteria.confidenceThreshold) {
        // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ”¹å–„ãŒå¿…è¦
        const template = plannerData.promptTemplates[evaluation.suggestionType];
        newPrompt = this.fillTemplate(template, {
            output: previousOutput,
            missing_details: evaluation.missingDetails,
            feedback: evaluation.feedback
        });
    }
    
    // å¯¾è±¡ãƒãƒ¼ãƒ‰ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ›´æ–°
    for (const targetNodeId of plannerData.targetNodes) {
        const targetNode = this.workflow.nodes.find(n => n.id === targetNodeId);
        if (targetNode && targetNode.type === 'llm') {
            targetNode.data.prompt = newPrompt || targetNode.data.prompt;
            console.log(`Planner updated prompt for node ${targetNodeId}`);
        }
    }
    
    return {
        evaluation: evaluation,
        updatedPrompt: newPrompt,
        targetNodes: plannerData.targetNodes
    };
}
```

## ãƒ•ã‚§ãƒ¼ã‚º4: å®Ÿè¡Œãƒ•ãƒ­ãƒ¼ã®æ”¹å–„

### 4.1 éåŒæœŸå®Ÿè¡Œã¨Branchãƒãƒ¼ãƒ‰ã®å®Ÿè£…

Branchãƒãƒ¼ãƒ‰ã§ã¯æ¡ä»¶ã«åŸºã¥ã„ã¦å‡¦ç†ã‚’åˆ†å²ã•ã›ã€å„åˆ†å²ã‚’éåŒæœŸã§å®Ÿè¡Œã—ã¾ã™ã€‚

```javascript
// Branchãƒãƒ¼ãƒ‰ã®è©³ç´°å®Ÿè£…
async executeBranchNode(node, inputs) {
    const branchData = node.data;
    const condition = branchData.condition;
    const inputValue = inputs.value || '';
    
    // æ¡ä»¶ã‚’è©•ä¾¡
    const evaluationResult = await this.evaluateCondition(condition, inputValue);
    
    // åˆ†å²å…ˆã®ãƒãƒ¼ãƒ‰ã‚’å–å¾—
    const connections = this.workflow.connections.filter(c => c.from === node.id);
    const trueBranch = connections.find(c => c.label === 'true');
    const falseBranch = connections.find(c => c.label === 'false');
    
    // éåŒæœŸå®Ÿè¡Œã®ãŸã‚ã®Promiseé…åˆ—
    const executionPromises = [];
    
    if (evaluationResult && trueBranch) {
        const trueNode = this.workflow.nodes.find(n => n.id === trueBranch.to);
        if (trueNode) {
            executionPromises.push(
                this.executeNode(trueNode, inputs)
                    .then(result => ({ branch: 'true', result }))
            );
        }
    }
    
    if (!evaluationResult && falseBranch) {
        const falseNode = this.workflow.nodes.find(n => n.id === falseBranch.to);
        if (falseNode) {
            executionPromises.push(
                this.executeNode(falseNode, inputs)
                    .then(result => ({ branch: 'false', result }))
            );
        }
    }
    
    // éåŒæœŸå®Ÿè¡Œ
    const results = await Promise.all(executionPromises);
    
    return {
        condition: condition,
        evaluationResult: evaluationResult,
        executedBranches: results
    };
}

// æ¡ä»¶è©•ä¾¡ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
async evaluateCondition(condition, inputValue) {
    // ã‚·ãƒ³ãƒ—ãƒ«ãªæ¡ä»¶è©•ä¾¡ã‹ã‚‰å§‹ã‚ã‚‹
    if (condition.includes('contains')) {
        const searchTerm = condition.match(/contains\s*"([^"]+)"/)?.[1];
        return inputValue.includes(searchTerm);
    }
    
    if (condition.includes('>') || condition.includes('<')) {
        // æ•°å€¤æ¯”è¼ƒ
        const match = condition.match(/(\w+)\s*([><=]+)\s*(\d+)/);
        if (match) {
            const value = parseFloat(inputValue);
            const threshold = parseFloat(match[3]);
            const operator = match[2];
            
            switch (operator) {
                case '>': return value > threshold;
                case '<': return value < threshold;
                case '>=': return value >= threshold;
                case '<=': return value <= threshold;
                case '=': return value === threshold;
            }
        }
    }
    
    // ã‚ˆã‚Šè¤‡é›‘ãªæ¡ä»¶ã¯JavaScriptã¨ã—ã¦è©•ä¾¡ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«æ³¨æ„ï¼‰
    try {
        const func = new Function('input', `return ${condition}`);
        return func(inputValue);
    } catch (e) {
        console.error('æ¡ä»¶è©•ä¾¡ã‚¨ãƒ©ãƒ¼:', e);
        return false;
    }
}
```

### 4.2 Merge Nodeã®åŒæœŸæ©Ÿèƒ½

Mergeãƒãƒ¼ãƒ‰ã¯éåŒæœŸå‡¦ç†ã®çµæœã‚’å¾…ã¡åˆã‚ã›ã‚‹é‡è¦ãªå½¹å‰²ã‚’æŒã¡ã¾ã™ã€‚

```javascript
// Mergeãƒãƒ¼ãƒ‰ã®å®Ÿè£…
async executeMergeNode(node, inputs) {
    const mergeData = node.data;
    
    // ã“ã®ãƒãƒ¼ãƒ‰ã¸ã®å…¨ã¦ã®å…¥åŠ›æ¥ç¶šã‚’å–å¾—
    const incomingConnections = this.workflow.connections.filter(c => c.to === node.id);
    
    // å…¨ã¦ã®å…¥åŠ›ãŒæƒã†ã¾ã§å¾…æ©Ÿ
    const pendingInputs = new Map();
    
    for (const connection of incomingConnections) {
        const sourceNodeId = connection.from;
        
        // æ—¢ã«å®Ÿè¡ŒçµæœãŒã‚ã‚‹å ´åˆ
        if (this.executionResults[sourceNodeId]) {
            pendingInputs.set(sourceNodeId, this.executionResults[sourceNodeId]);
        } else {
            // ã¾ã å®Ÿè¡Œã•ã‚Œã¦ã„ãªã„å ´åˆã¯å¾…æ©Ÿ
            console.log(`Merge node ${node.id} waiting for input from ${sourceNodeId}`);
            
            // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§å¾…æ©Ÿ
            const timeout = 30000; // 30ç§’
            const startTime = Date.now();
            
            while (!this.executionResults[sourceNodeId] && (Date.now() - startTime < timeout)) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (this.executionResults[sourceNodeId]) {
                pendingInputs.set(sourceNodeId, this.executionResults[sourceNodeId]);
            } else {
                console.error(`Timeout waiting for input from ${sourceNodeId}`);
            }
        }
    }
    
    // å…¥åŠ›ã‚’ãƒãƒ¼ã‚¸
    const mergedResult = this.performMerge(
        Array.from(pendingInputs.values()),
        mergeData.mergeStrategy,
        mergeData.separator
    );
    
    return {
        mergedData: mergedResult,
        inputCount: pendingInputs.size,
        sources: Array.from(pendingInputs.keys())
    };
}

// ãƒãƒ¼ã‚¸æˆ¦ç•¥ã®å®Ÿè£…
performMerge(inputs, strategy, separator = '\n') {
    switch (strategy) {
        case 'concat':
            // å˜ç´”ãªé€£çµ
            return inputs.map(input => 
                typeof input === 'string' ? input : JSON.stringify(input)
            ).join(separator);
            
        case 'array':
            // é…åˆ—ã¨ã—ã¦çµåˆ
            return inputs;
            
        case 'object':
            // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦çµåˆ
            return inputs.reduce((acc, input, index) => {
                acc[`input_${index}`] = input;
                return acc;
            }, {});
            
        case 'smart':
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦è‡ªå‹•åˆ¤å®š
            if (inputs.every(input => typeof input === 'string')) {
                return inputs.join(separator);
            } else if (inputs.every(input => typeof input === 'object')) {
                return Object.assign({}, ...inputs);
            } else {
                return inputs;
            }
            
        default:
            return inputs.join(separator);
    }
}
```

## ãƒ•ã‚§ãƒ¼ã‚º5: ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–ã¨ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–

### 5.1 å …ç‰¢ãªã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚·ã‚¹ãƒ†ãƒ 

ãƒ‡ãƒ¼ã‚¿ãƒ­ã‚¹ã‚’é˜²ããŸã‚ã€å¤šå±¤çš„ãªä¿å­˜æˆ¦ç•¥ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```javascript
// æ”¹å–„ã•ã‚ŒãŸã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–ã‚·ã‚¹ãƒ†ãƒ 
class AutoSaveManager {
    constructor(editor) {
        this.editor = editor;
        this.saveInterval = 5000; // 5ç§’
        this.lastSaveTime = null;
        this.pendingChanges = false;
        this.saveHistory = [];
        this.maxHistorySize = 10;
        
        this.initializeAutoSave();
    }
    
    initializeAutoSave() {
        // å®šæœŸä¿å­˜
        this.intervalId = setInterval(() => {
            if (this.pendingChanges) {
                this.performSave();
            }
        }, this.saveInterval);
        
        // é‡è¦ãªå¤‰æ›´æ™‚ã®å³æ™‚ä¿å­˜
        this.setupImmediateSaveTriggers();
        
        // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ä¿å­˜
        window.addEventListener('beforeunload', (e) => {
            if (this.pendingChanges) {
                this.performSave();
                e.preventDefault();
                e.returnValue = 'ä¿å­˜ã•ã‚Œã¦ã„ãªã„å¤‰æ›´ãŒã‚ã‚Šã¾ã™ã€‚';
            }
        });
    }
    
    setupImmediateSaveTriggers() {
        // ãƒãƒ¼ãƒ‰è¿½åŠ ãƒ»å‰Šé™¤æ™‚
        ['nodeAdded', 'nodeRemoved', 'connectionAdded', 'connectionRemoved'].forEach(event => {
            this.editor.on(event, () => {
                this.markChanged();
                this.performSave();
            });
        });
        
        // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´æ™‚ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ä»˜ãï¼‰
        let propertyChangeTimeout;
        this.editor.on('propertyChanged', () => {
            this.markChanged();
            clearTimeout(propertyChangeTimeout);
            propertyChangeTimeout = setTimeout(() => {
                this.performSave();
            }, 1000);
        });
    }
    
    performSave() {
        try {
            const saveData = {
                workflow: this.editor.workflow,
                metadata: {
                    savedAt: new Date().toISOString(),
                    version: '1.0.0',
                    nodeCount: this.editor.workflow.nodes.length,
                    connectionCount: this.editor.workflow.connections.length
                }
            };
            
            // ãƒ¡ã‚¤ãƒ³ä¿å­˜
            localStorage.setItem('llm-workflow-current', JSON.stringify(saveData));
            
            // å±¥æ­´ä¿å­˜
            this.saveToHistory(saveData);
            
            this.lastSaveTime = new Date();
            this.pendingChanges = false;
            
            // ä¿å­˜æˆåŠŸã®é€šçŸ¥
            this.editor.showNotification('è‡ªå‹•ä¿å­˜å®Œäº†', 'success');
            
        } catch (error) {
            console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            
            // localStorageãŒæº€æ¯ã®å ´åˆã®å¯¾å‡¦
            if (error.name === 'QuotaExceededError') {
                this.clearOldHistory();
                this.performSave(); // ãƒªãƒˆãƒ©ã‚¤
            }
        }
    }
    
    saveToHistory(saveData) {
        const historyKey = `llm-workflow-history-${Date.now()}`;
        this.saveHistory.push(historyKey);
        
        // å¤ã„å±¥æ­´ã‚’å‰Šé™¤
        while (this.saveHistory.length > this.maxHistorySize) {
            const oldKey = this.saveHistory.shift();
            localStorage.removeItem(oldKey);
        }
        
        localStorage.setItem(historyKey, JSON.stringify(saveData));
    }
    
    markChanged() {
        this.pendingChanges = true;
    }
}
```

ã“ã‚Œã‚‰ã®ä¿®æ­£ã«ã‚ˆã‚Šã€ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç›¤ã‹ã‚‰æ®µéšçš„ã«æ”¹å–„ã•ã‚Œã€ã‚ˆã‚Šå …ç‰¢ã§ä½¿ã„ã‚„ã™ã„ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã«ãªã‚Šã¾ã™ã€‚å„ãƒ•ã‚§ãƒ¼ã‚ºã¯ç‹¬ç«‹ã—ã¦å®Ÿè£…å¯èƒ½ã§ã™ãŒã€é †ç•ªã«å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå®‰å®šã—ãŸã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚

é‡è¦ãªã®ã¯ã€å„æ©Ÿèƒ½ãŒç›¸äº’ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«è¨­è¨ˆã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ä¸€éƒ¨ã®æ©Ÿèƒ½ã«å•é¡ŒãŒã‚ã£ã¦ã‚‚ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã¯å‹•ä½œã—ç¶šã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚


å„ªã‚ŒãŸLLMãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’å®Œæˆã•ã›ã‚‹ãŸã‚ã«ã€ã¾ã å®Ÿè£…ã•ã‚Œã¦ã„ãªã„é‡è¦ãªæ©Ÿèƒ½ã«ã¤ã„ã¦ã€ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®è¦–ç‚¹ã‹ã‚‰è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚ç¾åœ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’åˆ†æã™ã‚‹ã¨ã€åŸºæœ¬çš„ãªæ§‹é€ ã¯æ•´ã£ã¦ã„ã¾ã™ãŒã€å®Ÿéš›ã®é‹ç”¨ã§å¿…è¦ã¨ãªã‚‹å¤šãã®æ©Ÿèƒ½ãŒæ¬ ã‘ã¦ã„ã¾ã™ã€‚

## 1. å®Ÿè¡Œåˆ¶å¾¡ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½

ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã«ã¯ã€ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å®Ÿè¡Œã‚’ç´°ã‹ãåˆ¶å¾¡ã™ã‚‹æ©Ÿèƒ½ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å®Ÿéš›ã®ä½¿ç”¨å ´é¢ã‚’æƒ³åƒã—ã¦ã¿ã¦ãã ã•ã„ã€‚è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œä¸­ã«ã€ä½•ã‹å•é¡ŒãŒç™ºç”Ÿã—ãŸã‚‰ã©ã†ã—ã¾ã™ã‹ï¼Ÿ

### 1.1 ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã¨ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆ

ãƒ‡ãƒãƒƒã‚°ã®ãŸã‚ã«æœ€ã‚‚é‡è¦ãªæ©Ÿèƒ½ã®ä¸€ã¤ã§ã™ï¼š

```javascript
// ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
class DebugController {
    constructor(workflowEditor) {
        this.editor = workflowEditor;
        this.breakpoints = new Set();
        this.isPaused = false;
        this.currentNode = null;
        this.executionStack = [];
    }
    
    toggleBreakpoint(nodeId) {
        if (this.breakpoints.has(nodeId)) {
            this.breakpoints.delete(nodeId);
            this.updateBreakpointUI(nodeId, false);
        } else {
            this.breakpoints.add(nodeId);
            this.updateBreakpointUI(nodeId, true);
        }
    }
    
    async executeWithDebug(node, inputs) {
        // ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
        if (this.breakpoints.has(node.id)) {
            await this.pauseExecution(node, inputs);
        }
        
        // å®Ÿè¡Œå±¥æ­´ã«è¿½åŠ 
        this.executionStack.push({
            nodeId: node.id,
            inputs: JSON.parse(JSON.stringify(inputs)),
            timestamp: new Date()
        });
        
        // ãƒãƒ¼ãƒ‰å®Ÿè¡Œ
        const result = await this.editor.executeNode(node, inputs);
        
        // çµæœã‚‚å±¥æ­´ã«è¨˜éŒ²
        this.executionStack[this.executionStack.length - 1].output = result;
        
        return result;
    }
    
    updateBreakpointUI(nodeId, hasBreakpoint) {
        const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeElement) {
            if (hasBreakpoint) {
                // ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¿½åŠ 
                const indicator = document.createElement('div');
                indicator.className = 'breakpoint-indicator';
                indicator.innerHTML = 'ğŸ”´';
                nodeElement.appendChild(indicator);
            } else {
                // ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’å‰Šé™¤
                const indicator = nodeElement.querySelector('.breakpoint-indicator');
                if (indicator) indicator.remove();
            }
        }
    }
}
```

### 1.2 å®Ÿè¡Œé€Ÿåº¦åˆ¶å¾¡ã¨ã‚¹ãƒ†ãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®Ÿè¡Œã®æµã‚Œã‚’ç†è§£ã§ãã‚‹ã‚ˆã†ã«ã€é€Ÿåº¦ã‚’èª¿æ•´ã§ãã‚‹æ©Ÿèƒ½ãŒå¿…è¦ã§ã™ï¼š

```javascript
// å®Ÿè¡Œé€Ÿåº¦åˆ¶å¾¡ãƒ‘ãƒãƒ«ï¼ˆUIã«è¿½åŠ ï¼‰
<div id="execution-control-panel" class="fixed bottom-4 left-4 bg-white rounded-lg shadow-lg p-4">
    <h3 class="text-sm font-semibold mb-2">å®Ÿè¡Œåˆ¶å¾¡</h3>
    
    <div class="flex items-center space-x-2 mb-3">
        <button id="step-button" class="px-3 py-1 bg-blue-500 text-white rounded">
            ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
        </button>
        <button id="continue-button" class="px-3 py-1 bg-green-500 text-white rounded">
            ç¶™ç¶š
        </button>
        <button id="pause-button" class="px-3 py-1 bg-yellow-500 text-white rounded">
            ä¸€æ™‚åœæ­¢
        </button>
    </div>
    
    <div class="mb-2">
        <label class="text-xs font-medium">å®Ÿè¡Œé€Ÿåº¦</label>
        <input type="range" id="execution-speed" min="0" max="2000" value="500" 
               class="w-full"/>
        <div class="flex justify-between text-xs text-gray-500">
            <span>é«˜é€Ÿ</span>
            <span>æ¨™æº–</span>
            <span>ä½é€Ÿ</span>
        </div>
    </div>
</div>
```

## 2. ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã¨ãƒãƒƒãƒ”ãƒ³ã‚°æ©Ÿèƒ½

ç¾åœ¨ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯ã€ãƒãƒ¼ãƒ‰é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘æ¸¡ã™éš›ã®å¤‰æ›æ©Ÿèƒ½ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å®Ÿéš›ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã§ã¯ã€ã‚ã‚‹ãƒãƒ¼ãƒ‰ã®å‡ºåŠ›å½¢å¼ãŒæ¬¡ã®ãƒãƒ¼ãƒ‰ã®å…¥åŠ›å½¢å¼ã¨ä¸€è‡´ã—ãªã„ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚

### 2.1 Transform Nodeï¼ˆãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒãƒ¼ãƒ‰ï¼‰

```javascript
// æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚¿ã‚¤ãƒ—ã¨ã—ã¦è¿½åŠ 
{
    type: 'transform',
    label: 'Transform',
    description: 'Transform data between nodes',
    color: 'icon-transform',
    icon: '<path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>'
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‡ãƒ¼ã‚¿æ§‹é€ 
transform: {
    label: 'Data Transformer',
    transformType: 'json', // json, text, extract, template
    transformRules: [
        {
            source: 'input.text',
            target: 'output.content',
            operation: 'copy'
        }
    ],
    jsonPath: '',
    textPattern: '',
    template: '{{input}}'
}
```

### 2.2 è¦–è¦šçš„ãªãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ”ãƒ³ã‚°UI

ãƒãƒ¼ãƒ‰é–“ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’è¦–è¦šçš„ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã§ãã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒå¿…è¦ã§ã™ï¼š

```javascript
// ãƒ‡ãƒ¼ã‚¿ãƒãƒƒãƒ”ãƒ³ã‚°ãƒ¢ãƒ¼ãƒ€ãƒ«
class DataMappingModal {
    constructor(sourceNode, targetNode) {
        this.sourceNode = sourceNode;
        this.targetNode = targetNode;
        this.mappings = [];
    }
    
    render() {
        return `
            <div class="data-mapping-modal">
                <div class="mapping-container">
                    <div class="source-fields">
                        <h4>å‡ºåŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ (${this.sourceNode.data.label})</h4>
                        <div class="field-list">
                            ${this.renderFields(this.getOutputSchema(this.sourceNode))}
                        </div>
                    </div>
                    
                    <div class="mapping-lines">
                        <svg id="mapping-svg" width="100" height="300">
                            <!-- ãƒãƒƒãƒ”ãƒ³ã‚°ç·šãŒã“ã“ã«æç”»ã•ã‚Œã‚‹ -->
                        </svg>
                    </div>
                    
                    <div class="target-fields">
                        <h4>å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ (${this.targetNode.data.label})</h4>
                        <div class="field-list">
                            ${this.renderFields(this.getInputSchema(this.targetNode))}
                        </div>
                    </div>
                </div>
                
                <div class="transform-options">
                    <h4>å¤‰æ›ã‚ªãƒ—ã‚·ãƒ§ãƒ³</h4>
                    <select id="transform-type">
                        <option value="direct">ç›´æ¥ãƒãƒƒãƒ”ãƒ³ã‚°</option>
                        <option value="template">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¤‰æ›</option>
                        <option value="function">ã‚«ã‚¹ã‚¿ãƒ é–¢æ•°</option>
                    </select>
                </div>
            </div>
        `;
    }
}
```

## 3. ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã¨å±¥æ­´æ©Ÿèƒ½

ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å¤‰æ›´å±¥æ­´ã‚’è¿½è·¡ã—ã€å¿…è¦ã«å¿œã˜ã¦ä»¥å‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«æˆ»ã›ã‚‹æ©Ÿèƒ½ã¯ã€å®Ÿé‹ç”¨ã§ã¯å¿…é ˆã§ã™ã€‚

### 3.1 ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°

```javascript
class VersionManager {
    constructor(workflowEditor) {
        this.editor = workflowEditor;
        this.versions = [];
        this.currentVersion = 0;
        this.maxVersions = 50;
    }
    
    createSnapshot(description = '') {
        const snapshot = {
            id: `v${Date.now()}`,
            timestamp: new Date(),
            description: description,
            workflow: JSON.parse(JSON.stringify(this.editor.workflow)),
            nodeCount: this.editor.workflow.nodes.length,
            connectionCount: this.editor.workflow.connections.length
        };
        
        this.versions.push(snapshot);
        this.currentVersion = this.versions.length - 1;
        
        // å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å‰Šé™¤
        if (this.versions.length > this.maxVersions) {
            this.versions.shift();
            this.currentVersion--;
        }
        
        this.saveVersionsToStorage();
        this.updateVersionUI();
    }
    
    restoreVersion(versionIndex) {
        if (versionIndex >= 0 && versionIndex < this.versions.length) {
            const version = this.versions[versionIndex];
            
            // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ä¿å­˜
            this.createSnapshot('å¾©å…ƒå‰ã®è‡ªå‹•ä¿å­˜');
            
            // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å¾©å…ƒ
            this.editor.workflow = JSON.parse(JSON.stringify(version.workflow));
            this.editor.renderNodes();
            this.currentVersion = versionIndex;
            
            this.editor.showNotification(
                `ãƒãƒ¼ã‚¸ãƒ§ãƒ³ "${version.description}" ã‚’å¾©å…ƒã—ã¾ã—ãŸ`, 
                'success'
            );
        }
    }
}
```

### 3.2 å¤‰æ›´å·®åˆ†ã®å¯è¦–åŒ–

ã©ã“ãŒå¤‰æ›´ã•ã‚ŒãŸã‹ã‚’è¦–è¦šçš„ã«ç¢ºèªã§ãã‚‹æ©Ÿèƒ½ï¼š

```javascript
// å·®åˆ†è¡¨ç¤ºUI
<div id="version-diff-panel" class="version-diff-container">
    <div class="diff-header">
        <h3>å¤‰æ›´å±¥æ­´</h3>
        <select id="version-selector">
            <!-- ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒªã‚¹ãƒˆ -->
        </select>
    </div>
    
    <div class="diff-content">
        <div class="added-items">
            <h4>âœ… è¿½åŠ ã•ã‚ŒãŸè¦ç´ </h4>
            <ul id="added-list"></ul>
        </div>
        
        <div class="modified-items">
            <h4>âœï¸ å¤‰æ›´ã•ã‚ŒãŸè¦ç´ </h4>
            <ul id="modified-list"></ul>
        </div>
        
        <div class="removed-items">
            <h4>âŒ å‰Šé™¤ã•ã‚ŒãŸè¦ç´ </h4>
            <ul id="removed-list"></ul>
        </div>
    </div>
</div>
```

## 4. ãƒ†ã‚¹ãƒˆã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒæ­£ã—ãå‹•ä½œã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ãŒå¿…è¦ã§ã™ã€‚

### 4.1 ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç®¡ç†

```javascript
class TestCaseManager {
    constructor(workflowEditor) {
        this.editor = workflowEditor;
        this.testCases = [];
    }
    
    createTestCase(name, inputs, expectedOutputs) {
        const testCase = {
            id: `test_${Date.now()}`,
            name: name,
            inputs: inputs, // ãƒãƒ¼ãƒ‰IDã¨å…¥åŠ›å€¤ã®ãƒãƒƒãƒ—
            expectedOutputs: expectedOutputs, // ãƒãƒ¼ãƒ‰IDã¨æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ã®ãƒãƒƒãƒ—
            lastRun: null,
            status: 'not_run'
        };
        
        this.testCases.push(testCase);
        return testCase;
    }
    
    async runTestCase(testCaseId) {
        const testCase = this.testCases.find(tc => tc.id === testCaseId);
        if (!testCase) return;
        
        // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã®æº–å‚™
        const originalInputs = this.backupInputValues();
        
        try {
            // ãƒ†ã‚¹ãƒˆå…¥åŠ›ã‚’è¨­å®š
            this.applyTestInputs(testCase.inputs);
            
            // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ
            await this.editor.executeWorkflow();
            
            // çµæœã‚’æ¤œè¨¼
            const results = this.validateOutputs(testCase.expectedOutputs);
            
            testCase.lastRun = new Date();
            testCase.status = results.passed ? 'passed' : 'failed';
            testCase.results = results;
            
            return results;
            
        } finally {
            // å…ƒã®å…¥åŠ›å€¤ã‚’å¾©å…ƒ
            this.restoreInputValues(originalInputs);
        }
    }
}
```

### 4.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°

å„ãƒãƒ¼ãƒ‰ã®å®Ÿè¡Œæ™‚é–“ã‚’æ¸¬å®šã—ã€ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’ç‰¹å®šã™ã‚‹æ©Ÿèƒ½ï¼š

```javascript
// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒ¼
class PerformanceMonitor {
    constructor() {
        this.metrics = new Map();
    }
    
    startMeasurement(nodeId) {
        this.metrics.set(nodeId, {
            startTime: performance.now(),
            memoryBefore: performance.memory ? performance.memory.usedJSHeapSize : 0
        });
    }
    
    endMeasurement(nodeId) {
        const metric = this.metrics.get(nodeId);
        if (metric) {
            metric.endTime = performance.now();
            metric.duration = metric.endTime - metric.startTime;
            metric.memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
            metric.memoryDelta = metric.memoryAfter - metric.memoryBefore;
        }
        return metric;
    }
    
    generateReport() {
        const report = Array.from(this.metrics.entries())
            .map(([nodeId, metric]) => ({
                nodeId,
                duration: metric.duration,
                memoryUsage: metric.memoryDelta
            }))
            .sort((a, b) => b.duration - a.duration);
            
        return report;
    }
}
```

## 5. ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

ãƒãƒ¼ãƒ ã§ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’é–‹ç™ºã™ã‚‹å ´åˆã«å¿…è¦ãªæ©Ÿèƒ½ã§ã™ã€‚

### 5.1 ã‚³ãƒ¡ãƒ³ãƒˆã¨ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

```javascript
// ãƒãƒ¼ãƒ‰ã¸ã®ã‚³ãƒ¡ãƒ³ãƒˆæ©Ÿèƒ½
class CommentSystem {
    constructor() {
        this.comments = new Map();
    }
    
    addComment(nodeId, comment) {
        if (!this.comments.has(nodeId)) {
            this.comments.set(nodeId, []);
        }
        
        const commentData = {
            id: `comment_${Date.now()}`,
            text: comment,
            author: this.getCurrentUser(),
            timestamp: new Date(),
            resolved: false
        };
        
        this.comments.get(nodeId).push(commentData);
        this.renderCommentIndicator(nodeId);
        
        return commentData;
    }
    
    renderCommentIndicator(nodeId) {
        const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
        if (nodeElement) {
            const indicator = document.createElement('div');
            indicator.className = 'comment-indicator';
            indicator.innerHTML = `
                <span class="comment-count">
                    ğŸ’¬ ${this.comments.get(nodeId).length}
                </span>
            `;
            nodeElement.appendChild(indicator);
        }
    }
}
```

ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€LLMãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã¯å˜ãªã‚‹ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‹ã‚‰ã€å®Ÿéš›ã®æ¥­å‹™ã§ä½¿ç”¨ã§ãã‚‹æœ¬æ ¼çš„ãªãƒ„ãƒ¼ãƒ«ã¸ã¨é€²åŒ–ã—ã¾ã™ã€‚å„æ©Ÿèƒ½ã¯ç‹¬ç«‹ã—ã¦ã„ã‚‹ãŸã‚ã€å„ªå…ˆé †ä½ã‚’ã¤ã‘ã¦æ®µéšçš„ã«å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ç‰¹ã«é‡è¦ãªã®ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å‹•ä½œã‚’ç†è§£ã—ã€å•é¡Œã‚’ç´ æ—©ãç‰¹å®šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã‚„ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã¯ã€ãã®ãŸã‚ã®åŸºç›¤ã¨ãªã‚Šã¾ã™ã€‚
