<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ Universal Method Inspector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .config-panel {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .config-item {
            display: flex;
            flex-direction: column;
        }
        
        .config-item label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #495057;
        }
        
        .config-item input, .config-item select {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .config-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #1e7e34;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        
        .btn-warning:hover {
            background: #e0a800;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-info:hover {
            background: #117a8b;
        }
        
        .stats-panel {
            background: white;
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            text-align: center;
        }
        
        .stat-item {
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .filter-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
        }
        
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: end;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .section-title {
            font-size: 1.5em;
            color: #2c3e50;
            font-weight: 600;
        }
        
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 20px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .category-section {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }
        
        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px 15px;
            background: white;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        
        .category-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .category-count {
            background: #6c757d;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }
        
        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .method-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .method-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .method-item.success {
            border-left: 4px solid #28a745;
        }
        
        .method-item.error {
            border-left: 4px solid #dc3545;
        }
        
        .method-item.warning {
            border-left: 4px solid #ffc107;
        }
        
        .method-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .method-name {
            font-weight: 600;
            font-size: 1.1em;
            color: #2c3e50;
        }
        
        .method-status {
            font-size: 1.2em;
        }
        
        .method-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            color: #6c757d;
        }
        
        .method-class {
            font-family: monospace;
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .method-category {
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }
        
        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        .empty-state h3 {
            margin-bottom: 10px;
            color: #495057;
        }
        
        .duplicate-mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-button {
            padding: 12px 20px;
            border: 2px solid #dee2e6;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
        }
        
        .mode-button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.3);
            transform: translateY(-1px);
        }
        
        .mode-button:hover {
            background: #f8f9fa;
            border-color: #007bff;
            transform: translateY(-1px);
        }
        
        .mode-button.active:hover {
            background: #0056b3;
            border-color: #0056b3;
        }
        
        
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.info {
            background: #17a2b8;
        }
        
        .toast.success {
            background: #28a745;
        }
        
        .toast.warning {
            background: #ffc107;
            color: #212529;
        }
        
        .toast.error {
            background: #dc3545;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 8px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .method-grid {
                grid-template-columns: 1fr;
            }
            
            .config-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ü§ñ Universal Method Inspector</h1>
            <p>JavaScript Class Method Detection & Analysis Tool (Integrated Version)</p>
        </div>
        
        <!-- Action Panel -->
        <div class="config-panel">
            <div class="config-actions">
                <button class="btn btn-success" onclick="manualScan()">üîç Scan Methods</button>
                <button class="btn btn-warning" onclick="clearData()">üóëÔ∏è Clear Data</button>
                <button class="btn btn-info" onclick="exportData()">üì§ Export Results</button>
            </div>
        </div>
        
        <!-- Statistics Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalMethods">0</div>
                    <div class="stat-label">Total Methods</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="lastScanTime">Never</div>
                    <div class="stat-label">Last Scan</div>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="filter-panel">
                <div class="filter-grid">
                    <div class="config-item">
                        <label for="searchMethod">Search Methods</label>
                        <input type="text" id="searchMethod" placeholder="Type method name..." oninput="applyFilters()">
                    </div>
                    <div class="config-item" id="similarityFilter" style="display: none;">
                        <label for="similarityThreshold">È°û‰ººÂ∫¶„Åó„Åç„ÅÑÂÄ§ (%)</label>
                        <input type="range" id="similarityThreshold" min="0" max="100" value="0" oninput="updateSimilarityFilter(this.value)">
                        <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: #6c757d; margin-top: 2px;">
                            <span>0%</span>
                            <span id="similarityValue">0%</span>
                            <span>100%</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Mode Toggle -->
            <div class="duplicate-mode-toggle">
                <button class="mode-button active" id="methodMode" onclick="switchMode('methods')">
                    üìã Method Detection
                </button>
                <button class="mode-button" id="duplicateMode" onclick="switchMode('duplicates')">
                    üîç Duplicate Analysis
                </button>
            </div>

            <!-- Results Section -->
            <div class="section-header">
                <div class="section-title" id="sectionTitle">üîç Detected Methods</div>
                <button class="btn btn-primary" onclick="refreshDisplay()">üîÑ Refresh Display</button>
            </div>
            
            <div id="resultsContainer">
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>Initializing Universal Method Inspector...</div>
                    <div style="margin-top: 10px; font-size: 0.9em; color: #6c757d;">
                        Click "Scan Methods" to detect JavaScript methods in your project
                    </div>
                </div>
            </div>
        </div>
        

    </div>

    <!-- **‰øÆÊ≠£**: Load all actual project JavaScript files for real method detection -->
    <script src="debug-monitor.js"></script>
    <script src="llm.js"></script>
    <script src="node-manager.js"></script>
    <script src="connection-manager.js"></script>
    <script src="event-handlers.js"></script>
    <script src="ui-manager.js"></script>
    <script src="workflow-executor.js"></script>
    <script src="workflow-editor.js"></script>
    <script src="universal-method-inspector.js"></script>
    
    <!-- **‰øÆÊ≠£**: ÂøÖË¶Å„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê -->
    <script>
        // **ÈáçË¶Å**: „ÉÜ„Çπ„ÉàÁí∞Â¢É„Åß„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê
        console.log('üîß Creating object instances for testing...');
        
        try {
            // DebugMonitor„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê
            if (typeof DebugMonitor !== 'undefined') {
                window.debugMonitor = new DebugMonitor();
                console.log('‚úÖ debugMonitor instance created');
            }
            
            // WorkflowEditor„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàêÔºà„Ç®„É©„Éº„ÅåÁô∫Áîü„Åô„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ try-catch „ÅßÂõ≤„ÇÄÔºâ
            if (typeof WorkflowEditor !== 'undefined') {
                // **‰øÆÊ≠£**: WorkflowEditor„Å´ÂøÖË¶Å„Å™ÂÆåÂÖ®„Å™DOMÊßãÈÄ†„Çí‰ΩúÊàê
                const requiredElements = [
                    { id: 'canvas', tag: 'div', styles: { display: 'none', position: 'relative', width: '100px', height: '100px' } },
                    { id: 'connections-svg', tag: 'svg', styles: { display: 'none', position: 'absolute', top: '0', left: '0', width: '100px', height: '100px' } },
                    { id: 'node-palette', tag: 'div', styles: { display: 'none' } },
                    { id: 'property-panel', tag: 'div', styles: { display: 'none' } },
                    { id: 'welcome-message', tag: 'div', styles: { display: 'none' } },
                    { id: 'connection-status', tag: 'div', styles: { display: 'none' } },
                    { id: 'workflow-controls', tag: 'div', styles: { display: 'none' } }
                ];
                
                requiredElements.forEach(({ id, tag, styles }) => {
                    if (!document.getElementById(id)) {
                        const element = tag === 'svg' 
                            ? document.createElementNS('http://www.w3.org/2000/svg', 'svg')
                            : document.createElement(tag);
                        element.id = id;
                        
                        // „Çπ„Çø„Ç§„É´„ÇíÈÅ©Áî®
                        Object.assign(element.style, styles);
                        
                        document.body.appendChild(element);
                        console.log(`‚úÖ Created DOM element: ${id}`);
                    }
                });
                
                // **ËøΩÂä†**: WorkflowEditorÂàùÊúüÂåñÂâç„Å´„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„ÇíË®≠ÂÆö
                window.workflowEditor = null; // ÂàùÊúüÂåñ
                
                try {
                    window.workflowEditor = new WorkflowEditor();
                    console.log('‚úÖ workflowEditor instance created successfully');
                    
                    // **ËøΩÂä†**: „Çµ„Éñ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÁ¢∫Ë™ç
                    if (window.workflowEditor.connectionManager) {
                        console.log('‚úÖ connectionManager sub-object available');
                    }
                    if (window.workflowEditor.nodeManager) {
                        console.log('‚úÖ nodeManager sub-object available');
                    }
                    if (window.workflowEditor.uiManager) {
                        console.log('‚úÖ uiManager sub-object available');
                    }
                    if (window.workflowEditor.eventHandlers) {
                        console.log('‚úÖ eventHandlers sub-object available');
                    }
                    if (window.workflowEditor.workflowExecutor) {
                        console.log('‚úÖ workflowExecutor sub-object available');
                    }
                    
                } catch (initError) {
                    console.error('‚ùå WorkflowEditor initialization failed:', initError.message);
                    console.error('Stack trace:', initError.stack);
                    
                    // **„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ**: ÊúÄÂ∞èÈôê„ÅÆ„É¢„ÉÉ„ÇØ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
                    window.workflowEditor = {
                        getIcon: (type) => `<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>`,
                        nodeTypes: [],
                        workflow: { nodes: [], connections: [] },
                        connectionManager: null,
                        nodeManager: null,
                        uiManager: null,
                        eventHandlers: null,
                        workflowExecutor: null
                    };
                    console.log('‚ö†Ô∏è Created fallback workflowEditor mock object');
                }
            }
            
        } catch (error) {
            console.warn('‚ö†Ô∏è Some object instances could not be created:', error.message);
            // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„ÉÜ„Çπ„Éà„ÅØÁ∂öË°å
        }
        
        console.log('üîß Object instance creation completed');
    </script>
    
    <script>
        // Universal Method Inspector - Integrated Version
        class UniversalMethodInspector {
            constructor() {
                this.discoveredMethods = new Map();
                this.targetObjects = new Set();
                this.excludePrivate = true;
                
                console.log('UniversalMethodInspector instance created (integrated)');
            }

            autoDetectGlobalObjects() {
                this.targetObjects.clear();
                
                const commonPatterns = [
                    'workflowEditor', 'editor', 'manager', 'controller', 'handler', 
                    'service', 'processor', 'engine', 'app', 'main', 'system',
                    'uiManager', 'connectionManager', 'nodeManager', 'eventHandler',
                    'workflowExecutor', 'debugMonitor'
                ];
                
                for (const key in window) {
                    try {
                        const obj = window[key];
                        if (obj && typeof obj === 'object' && obj.constructor && obj.constructor.name) {
                            const className = obj.constructor.name;
                            
                            if (!this.isBuiltInObject(className) && this.hasCustomMethods(obj)) {
                                this.targetObjects.add(key);
                            }
                        }
                        
                        if (commonPatterns.some(pattern => 
                            key.toLowerCase().includes(pattern.toLowerCase()) ||
                            pattern.toLowerCase().includes(key.toLowerCase())
                        )) {
                            if (obj && typeof obj === 'object') {
                                this.targetObjects.add(key);
                            }
                        }
                    } catch (e) {
                        // „Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Å™„ÅÑ„Éó„É≠„Éë„ÉÜ„Ç£„Çí„Çπ„Ç≠„ÉÉ„Éó
                    }
                }
                
                console.log(`üîç Ê§úÂá∫„Åï„Çå„Åü„Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà:`, Array.from(this.targetObjects));
            }

            isBuiltInObject(className) {
                const builtInTypes = [
                    'Object', 'Array', 'String', 'Number', 'Boolean', 'Function',
                    'Date', 'RegExp', 'Error', 'Promise', 'Map', 'Set', 'WeakMap', 'WeakSet',
                    'HTMLElement', 'HTMLDocument', 'Window', 'XMLHttpRequest',
                    'Event', 'MouseEvent', 'KeyboardEvent', 'Node', 'Element',
                    'HTMLDivElement', 'HTMLScriptElement', 'HTMLButtonElement',
                    'HTMLInputElement', 'HTMLTextAreaElement', 'HTMLSelectElement',
                    'CSSStyleDeclaration', 'Location', 'History', 'Navigator',
                    'Screen', 'Storage', 'Console', 'Performance'
                ];
                return builtInTypes.includes(className);
            }

            hasCustomMethods(obj) {
                try {
                    const proto = Object.getPrototypeOf(obj);
                    if (!proto) return false;
                    
                    const methods = Object.getOwnPropertyNames(proto)
                        .filter(name => typeof obj[name] === 'function' && name !== 'constructor');
                    
                    return methods.length > 0;
                } catch (e) {
                    return false;
                }
            }

            async scanForMethods() {
                console.log('üîç Starting comprehensive method scan...');
                this.discoveredMethods.clear();

                try {
                    // **Âº∑Âåñ**: „Çà„ÇäÂåÖÊã¨ÁöÑ„Å™„Çπ„Ç≠„É£„É≥ÊâãÈ†Ü
                    
                    // 1. ÂÆüÈöõ„ÅÆJavaScript„Éï„Ç°„Ç§„É´„Å®„Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„Çπ„Ç≠„É£„É≥
                    await this.scanJavaScriptFiles();
                    
                    // 2. ËøΩÂä†„ÅßÂÖ®„Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞„Çí„Çπ„Ç≠„É£„É≥
                    this.scanGlobalFunctions();
                    
                    // 3. inspector„É°„ÇΩ„ÉÉ„ÉâÔºà„Åì„ÅÆHTML„Éï„Ç°„Ç§„É´Ôºâ„ÇíËøΩÂä†
                    if (window.inspector) {
                        console.log(`üîç „Çπ„Ç≠„É£„É≥‰∏≠: inspector (this file)`);
                        const methods = this.discoverMethods(window.inspector, 'inspector');
                        methods.forEach(method => {
                            const key = `${method.className}.${method.name}`;
                            // ÂÑ™ÂÖàÂ∫¶„ÇíËÄÉÊÖÆ„Åó„Å¶ËøΩÂä†Ôºà„Éï„Ç°„Ç§„É´ÂàÜÊûê„ÅåÂÑ™ÂÖàÔºâ
                            if (!this.discoveredMethods.has(key)) {
                                this.discoveredMethods.set(key, method);
                            }
                        });
                    }

                    // 4. **ËøΩÂä†**: Ë¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                    if (this.discoveredMethods.size < 10) {
                        console.log('‚ö†Ô∏è Few methods found, running fallback comprehensive scan...');
                        this.scanAllAvailableObjects();
                    }

                    // **‰øÆÊ≠£**: „ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÊäΩÂá∫„Ç®„É©„Éº„ÅÆÊ§úÂá∫„Å®Â†±Âëä
                    const methodsWithoutSource = Array.from(this.discoveredMethods.values())
                        .filter(method => !method.sourceCode || !method.sourceCode.available);
                    
                    if (methodsWithoutSource.length > 0) {
                        console.log(`‚ö†Ô∏è ${methodsWithoutSource.length} methods without source code:`, 
                            methodsWithoutSource.map(m => `${m.className}.${m.name}`));
                    }

                    this.generateDisplay();
                    this.updateStatistics();

                    const fileCount = new Set(Array.from(this.discoveredMethods.values()).map(m => m.filename)).size;
                    console.log(`üîç Final scan results: ${this.discoveredMethods.size} methods from ${fileCount} files`);
                    
                    if (this.discoveredMethods.size === 0) {
                        this.showToast('No methods found. Check console for debugging info.', 'warning');
                } else {
                        this.showToast(`Scan completed. ${this.discoveredMethods.size} methods found from ${fileCount} files`, 'success');
                    }

                } catch (error) {
                    console.error('Error during method scanning:', error);
                    this.showToast('Error during scanning: ' + error.message, 'error');
                }
            }

            scanGlobalFunctions() {
                console.log('üîç Scanning global functions...');
                
                for (const key in window) {
                    try {
                        if (typeof window[key] === 'function' && 
                            !key.startsWith('_') && 
                            !key.includes('$') &&
                            !this.isBuiltInFunction(key)) {
                            
                            const method = {
                                name: key,
                                className: 'GlobalFunctions',
                                fullPath: `window.${key}`,
                                filename: 'global-functions',
                                discovered: Date.now(),
                                source: 'global-function'
                            };
                            
                            const methodKey = `${method.className}.${method.name}`;
                            this.discoveredMethods.set(methodKey, method);
                        }
                    } catch (e) {
                        // Skip inaccessible functions
                    }
                }
            }

            scanAllAvailableObjects() {
                console.log('üîç Running fallback: scanning ALL available objects...');
                
                for (const key in window) {
                    try {
                        const obj = window[key];
                        if (obj && typeof obj === 'object' && obj.constructor) {
                            const className = obj.constructor.name;
                            
                            // „Çà„ÇäÁ∑©„ÅÑÊù°‰ª∂„Åß„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂèó„ÅëÂÖ•„Çå
                            if (!this.isBuiltInObject(className) && 
                                typeof obj === 'object' && 
                                !key.startsWith('_') && 
                                !key.includes('$')) {
                                
                                const methods = this.discoverMethods(obj, key);
                                if (methods.length > 0) {
                                    methods.forEach(method => {
                                        method.filename = this.guessFilename(key) || 'unknown-source';
                                        method.source = 'fallback-scan';
                                        
                                        const methodKey = `${method.className}.${method.name}`;
                                        if (!this.discoveredMethods.has(methodKey)) {
                                            this.discoveredMethods.set(methodKey, method);
                                        }
                                    });
                                    
                                    console.log(`‚úÖ Fallback found ${methods.length} methods in: ${key} (${className})`);
                                }
                            }
                        }
                    } catch (e) {
                        // Skip inaccessible properties
                    }
                }
            }

            isBuiltInFunction(functionName) {
                const builtInFunctions = [
                    'alert', 'confirm', 'prompt', 'setTimeout', 'setInterval', 'clearTimeout', 'clearInterval',
                    'fetch', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'encodeURIComponent', 'decodeURIComponent',
                    'open', 'close', 'focus', 'blur', 'print', 'stop', 'addEventListener', 'removeEventListener',
                    'requestAnimationFrame', 'cancelAnimationFrame'
                ];
                return builtInFunctions.includes(functionName);
            }

            getLimitedWindowMethods() {
                // Return only essential browser APIs for demo purposes
                const essentialAPIs = ['localStorage', 'sessionStorage', 'console'];
                const methods = [];
                
                essentialAPIs.forEach(apiName => {
                    if (window[apiName]) {
                        const apiMethods = this.discoverMethods(window[apiName], apiName);
                        methods.push(...apiMethods.slice(0, 3)); // Limit to 3 methods per API
                    }
                });
                
                return methods;
            }

            async scanJavaScriptFiles() {
                console.log('üìÅ Scanning loaded JavaScript files and global objects...');
                
                // ÂÆüÈöõ„Å´„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Çã„Çπ„ÇØ„É™„Éó„Éà„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫
                const loadedScripts = this.detectLoadedScripts();
                console.log('üîç Detected loaded scripts:', loadedScripts);
                
                // „Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÂÆüÈöõ„ÅÆÈñ¢Êï∞„ÇíÊäΩÂá∫
                this.extractFromGlobalObjects();
                
                // „É≠„Éº„Éâ„Åï„Çå„Åü„Çπ„ÇØ„É™„Éó„Éà„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„Åì„Åã„Çâ„ÇÇÊäΩÂá∫„ÇíË©¶Ë°å
                for (const scriptInfo of loadedScripts) {
                    this.extractFunctionsFromGlobalScope(scriptInfo.filename, scriptInfo.src);
                }
            }

            detectLoadedScripts() {
                console.log('üîç Detecting loaded JavaScript files...');
                const scripts = [];
                
                // document.scripts „Åã„ÇâÂÆüÈöõ„Å´„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Çã„Çπ„ÇØ„É™„Éó„Éà„ÇíÂèñÂæó
                Array.from(document.scripts).forEach(script => {
                    if (script.src) {
                        const filename = script.src.split('/').pop();
                        if (filename.endsWith('.js')) {
                            scripts.push({
                                filename: filename,
                                src: script.src,
                                element: script
                            });
                        }
                    }
                });
                
                return scripts;
            }

            extractFromGlobalObjects() {
                console.log('üîç Extracting functions from global objects...');
                
                // **Âº∑Âåñ**: „Çà„ÇäÂåÖÊã¨ÁöÑ„Å™„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Éë„Çø„Éº„É≥
                const projectPatterns = [
                    'workflowEditor', 'WorkflowEditor',
                    'uiManager', 'UIManager', 
                    'connectionManager', 'ConnectionManager',
                    'nodeManager', 'NodeManager',
                    'eventHandler', 'EventHandler', 'eventHandlers', 'EventHandlers',
                    'debugMonitor', 'DebugMonitor',
                    'workflowExecutor', 'WorkflowExecutor',
                    'llm', 'LLM',
                    'inspector', // inspector „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÇÂê´„ÇÅ„Çã
                    'UniversalMethodInspector' // „ÇØ„É©„Çπ„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„ÇÇÂê´„ÇÅ„Çã
                ];

                // **ËøΩÂä†**: „ÇØ„É©„Çπ„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„Åã„Çâ„ÇÇ„É°„ÇΩ„ÉÉ„Éâ„ÇíÊäΩÂá∫
                this.extractFromClassConstructors();
                
                // „Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„Çπ„Ç≠„É£„É≥Ôºà„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈñ¢ÈÄ£„ÅÆ„ÅøÔºâ
                let foundObjects = 0;
                for (const key in window) {
                    try {
                        const obj = window[key];
                        if (obj && typeof obj === 'object' && obj.constructor) {
                            const className = obj.constructor.name;
                            
                            // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈñ¢ÈÄ£„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                            const isProjectObject = projectPatterns.some(pattern => 
                                key.toLowerCase().includes(pattern.toLowerCase()) ||
                                className.toLowerCase().includes(pattern.toLowerCase())
                            );
                            
                            // **ÊîπÂñÑ**: „Çà„ÇäÂé≥ÂØÜ„Åß„Å™„ÅÑÊù°‰ª∂„ÇÇËøΩÂä†
                            const hasCustomMethods = this.hasCustomMethods(obj);
                            const isLikelyProjectObject = 
                                isProjectObject || 
                                (hasCustomMethods && !this.isBuiltInObject(className) && 
                                 !key.startsWith('_') && !key.includes('$') && 
                                 className !== 'Object' && className !== 'Function');
                            
                            // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈñ¢ÈÄ£„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ„ÅøÂá¶ÁêÜ
                            if (isLikelyProjectObject) {
                                const methods = this.discoverMethods(obj, key);
                                methods.forEach(method => {
                                    // „Éï„Ç°„Ç§„É´Âêç„ÇíÊé®Ê∏¨„Åó„Å¶Ë®≠ÂÆö
                                    method.filename = this.guessFilename(key);
                                    method.source = 'global-object';
                                    
                                    const methodKey = `${method.className}.${method.name}`;
                                    this.discoveredMethods.set(methodKey, method);
                                });
                                
                                if (methods.length > 0) {
                                    console.log(`‚úÖ Found ${methods.length} methods in global object: ${key} (${className})`);
                                    foundObjects++;
                                }
                            }
                        }
                    } catch (e) {
                        // „Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Å™„ÅÑ„Éó„É≠„Éë„ÉÜ„Ç£„Çí„Çπ„Ç≠„ÉÉ„Éó
                    }
                }
                
                console.log(`üîç Total project objects found: ${foundObjects}`);
            }

            extractFromClassConstructors() {
                console.log('üîç Extracting methods from class constructors...');
                
                // **Êñ∞Ê©üËÉΩ**: „Ç∞„É≠„Éº„Éê„É´„ÇØ„É©„Çπ„Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø„Åã„Çâ„Éó„É≠„Éà„Çø„Ç§„Éó„É°„ÇΩ„ÉÉ„Éâ„ÇíÊäΩÂá∫
                const knownClasses = [
                    'WorkflowEditor', 'NodeManager', 'ConnectionManager', 
                    'EventHandlers', 'UIManager', 'WorkflowExecutor',
                    'DebugMonitor', 'UniversalMethodInspector'
                ];
                
                knownClasses.forEach(className => {
                    if (window[className] && typeof window[className] === 'function') {
                        const classConstructor = window[className];
                        const prototype = classConstructor.prototype;
                        
                        if (prototype) {
                            const methods = this.discoverMethods(prototype, className);
                            methods.forEach(method => {
                                method.filename = this.guessFilename(className);
                                method.source = 'class-prototype';
                                method.className = className; // Ensure correct class name
                                
                                const methodKey = `${method.className}.${method.name}`;
                                this.discoveredMethods.set(methodKey, method);
                            });
                            
                            if (methods.length > 0) {
                                console.log(`‚úÖ Found ${methods.length} prototype methods in class: ${className}`);
                            }
                        }
                    }
                });
            }

            extractFunctionsFromGlobalScope(filename, src) {
                console.log(`üîç Analyzing global scope for ${filename}...`);
                
                // „Éï„Ç°„Ç§„É´Âêç„Åã„Çâ„ÇØ„É©„ÇπÂêç„ÇíÊé®Ê∏¨
                const baseName = filename.replace('.js', '');
                const className = this.fileNameToClassName(baseName);
                
                // „Åù„ÅÆ„ÇØ„É©„ÇπÂêç„Å´ÂØæÂøú„Åô„Çã„Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊé¢„Åô
                const possibleNames = [
                    className,
                    baseName,
                    baseName.replace(/-/g, ''),
                    this.kebabToCamel(baseName)
                ];
                
                for (const name of possibleNames) {
                    if (window[name] && typeof window[name] === 'object') {
                        const methods = this.discoverMethods(window[name], name);
                        methods.forEach(method => {
                            method.filename = filename;
                            method.source = 'script-analysis';
                            
                            const key = `${method.className}.${method.name}`;
                            this.discoveredMethods.set(key, method);
                        });
                        
                        if (methods.length > 0) {
                            console.log(`‚úÖ Found ${methods.length} methods from ${filename} via global object ${name}`);
                        }
                        break;
                    }
                }
            }

            fileNameToClassName(filename) {
                // workflow-editor -> WorkflowEditor
                return filename.split('-')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join('');
            }

            kebabToCamel(str) {
                // workflow-editor -> workflowEditor
                return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
            }

            discoverMethods(obj, className) {
                if (!obj || typeof obj !== 'object') return [];
                
                const methods = [];
                
                // **Âº∑Âåñ**: „Çà„ÇäÂ§ö„Åè„ÅÆÊ®ôÊ∫ñ„É°„ÇΩ„ÉÉ„Éâ„ÇíÈô§Â§ñ
                const excludedMethods = new Set([
                    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
                    'toString', 'valueOf', 'toLocaleString', 'constructor',
                    'then', 'catch', 'finally', // PromiseÈñ¢ÈÄ£
                    'addEventListener', 'removeEventListener', 'dispatchEvent' // EventÈñ¢ÈÄ£
                ]);
                
                // **ËøΩÂä†**: ÂÆüÈöõ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
                const isRealProjectClass = ['WorkflowEditor', 'UIManager', 'ConnectionManager', 
                                          'NodeManager', 'EventHandlers', 'WorkflowExecutor', 
                                          'DebugMonitor'].includes(obj.constructor?.name);
                
                // Áõ¥Êé•ÂÆöÁæ©„Åï„Çå„Åü„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„Åø„ÇíÂèñÂæóÔºà„Éó„É≠„Éà„Çø„Ç§„Éó„ÉÅ„Çß„Éº„É≥„ÅØÈô§Â§ñÔºâ
                const directMethods = Object.getOwnPropertyNames(obj)
                    .filter(name => {
                        try {
                            return typeof obj[name] === 'function' &&
                                   !excludedMethods.has(name) &&
                                   (!this.excludePrivate || !name.startsWith('_'));
                        } catch (e) {
                            return false;
                        }
                    });

                // **ÊîπÂñÑ**: „Éó„É≠„Éà„Çø„Ç§„Éó„Åã„ÇâÁ∂ôÊâø„Åï„Çå„Åü„Ç´„Çπ„Çø„É†„É°„ÇΩ„ÉÉ„Éâ„ÇÇÂèñÂæóÔºàÁâπ„Å´ÂÆüÈöõ„ÅÆ„ÇØ„É©„Çπ„ÅÆÂ†¥ÂêàÔºâ
                const proto = Object.getPrototypeOf(obj);
                if (proto && proto !== Object.prototype) {
                    const protoMethods = Object.getOwnPropertyNames(proto)
                        .filter(name => {
                            try {
                                return typeof proto[name] === 'function' && 
                                       !excludedMethods.has(name) &&
                                       (!this.excludePrivate || !name.startsWith('_'));
                            } catch (e) {
                                return false;
                            }
                        });
                    directMethods.push(...protoMethods);
                }

                const allMethods = [...new Set(directMethods)];
                
                allMethods.forEach(methodName => {
                    // **‰øÆÊ≠£**: „ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÊäΩÂá∫„ÇíÂÆâÂÖ®„Å´ÂÆüË°å
                    let sourceCodeInfo;
                    try {
                        sourceCodeInfo = this.extractMethodSourceCode(obj, methodName, className);
                    } catch (error) {
                        console.warn(`Failed to extract source code for ${className}.${methodName}:`, error);
                        sourceCodeInfo = {
                            raw: '',
                            cleaned: '',
                            length: 0,
                            lines: 0,
                            signature: '',
                            available: false
                        };
                    }
                    
                    // **‰øÆÊ≠£**: sourceCodeInfo„Ååundefined„ÅÆÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                    if (!sourceCodeInfo) {
                        sourceCodeInfo = {
                            raw: '',
                            cleaned: '',
                            length: 0,
                            lines: 0,
                            signature: '',
                            available: false
                        };
                    }

                    const methodInfo = {
                        name: methodName,
                        className: className,
                        fullPath: `${className}.${methodName}`,
                        filename: this.guessFilename(className),
                        discovered: Date.now(),
                        isRealProject: isRealProjectClass, // **ËøΩÂä†**: ÂÆüÈöõ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„É°„ÇΩ„ÉÉ„Éâ„Åã„Éï„É©„Ç∞
                        source: isRealProjectClass ? 'real-project' : 'test-object',
                        sourceCode: sourceCodeInfo // **‰øÆÊ≠£**: ÂÆâÂÖ®„Å´ÊäΩÂá∫„Åï„Çå„Åü„ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÊÉÖÂ†±
                    };
                    methods.push(methodInfo);
                });

                // **„Éá„Éê„ÉÉ„Ç∞**: Áô∫Ë¶ã„Åï„Çå„Åü„É°„ÇΩ„ÉÉ„Éâ„ÅÆË©≥Á¥∞„É≠„Ç∞
                if (methods.length > 0) {
                    const sourceType = isRealProjectClass ? 'REAL PROJECT' : 'test object';
                    console.log(`üîç Discovered ${methods.length} methods from ${sourceType}: ${className}`);
                    if (isRealProjectClass) {
                        console.log(`  üìã Real methods: ${methods.map(m => m.name).join(', ')}`);
                    }
                }

                return methods;
            }

            // **Êñ∞Ê©üËÉΩ**: „É°„ÇΩ„ÉÉ„Éâ„ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÊäΩÂá∫
            extractMethodSourceCode(obj, methodName, className) {
                try {
                    let method = null;
                    
                    // Áõ¥Êé•„Éó„É≠„Éë„ÉÜ„Ç£„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
                    if (obj[methodName] && typeof obj[methodName] === 'function') {
                        method = obj[methodName];
                    }
                    
                    // „Éó„É≠„Éà„Çø„Ç§„Éó„Åã„ÇâÂèñÂæó„ÇíË©¶Ë°å
                    if (!method) {
                        const proto = Object.getPrototypeOf(obj);
                        if (proto && proto[methodName] && typeof proto[methodName] === 'function') {
                            method = proto[methodName];
                        }
                    }
                    
                    if (method && typeof method === 'function') {
                        try {
                            const sourceCode = method.toString();
                            
                            // Âü∫Êú¨ÁöÑ„Å™„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÇØ„É™„Éº„Éã„É≥„Ç∞
                            const cleanedCode = sourceCode
                                .replace(/^\s+/gm, '') // Ë°åÈ†≠„ÅÆÁ©∫ÁôΩ„ÇíÂâäÈô§
                                .replace(/\s+$/gm, '') // Ë°åÊú´„ÅÆÁ©∫ÁôΩ„ÇíÂâäÈô§
                                .replace(/\n{2,}/g, '\n') // Ë§áÊï∞„ÅÆÊîπË°å„Çí1„Å§„Å´
                                .trim();
                            
                            return {
                                raw: sourceCode,
                                cleaned: cleanedCode,
                                length: sourceCode.length,
                                lines: sourceCode.split('\n').length,
                                signature: this.extractFunctionSignature(sourceCode),
                                available: true
                            };
                        } catch (toStringError) {
                            console.warn(`Failed to convert method to string for ${className}.${methodName}:`, toStringError);
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to extract source code for ${className}.${methodName}:`, error);
                }
                
                return {
                    raw: '',
                    cleaned: '',
                    length: 0,
                    lines: 0,
                    signature: '',
                    available: false
                };
            }

            // **Êñ∞Ê©üËÉΩ**: Èñ¢Êï∞„Ç∑„Ç∞„Éç„ÉÅ„É£„ÅÆÊäΩÂá∫
            extractFunctionSignature(sourceCode) {
                try {
                    // Èñ¢Êï∞ÂÆ£Ë®Ä„Åæ„Åü„ÅØ„Ç¢„É≠„ÉºÈñ¢Êï∞„ÅÆ„Ç∑„Ç∞„Éç„ÉÅ„É£„ÇíÊäΩÂá∫
                    const signatureMatch = sourceCode.match(/^(?:async\s+)?(?:function\s*)?(\w*)\s*\(([^)]*)\)/);
                    if (signatureMatch) {
                        const functionName = signatureMatch[1] || 'anonymous';
                        const parameters = signatureMatch[2].trim();
                        return `${functionName}(${parameters})`;
                    }
                    
                    // „Ç¢„É≠„ÉºÈñ¢Êï∞„ÅÆÂ†¥Âêà
                    const arrowMatch = sourceCode.match(/^\s*\(([^)]*)\)\s*=>/);
                    if (arrowMatch) {
                        const parameters = arrowMatch[1].trim();
                        return `(${parameters}) =>`;
                    }
                    
                    return 'unknown signature';
                } catch (error) {
                    return 'extraction failed';
                }
            }

            // **Êñ∞Ê©üËÉΩ**: „Ç≥„Éº„ÉâÈ°û‰ººÂ∫¶ÂàÜÊûê„Ç®„É≥„Ç∏„É≥
            analyzeCodeSimilarity(method1, method2) {
                // **‰øÆÊ≠£**: sourceCode„ÅÆÂÆâÂÖ®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ„ÇíÂº∑Âåñ
                const sourceCode1 = method1.sourceCode || { available: false };
                const sourceCode2 = method2.sourceCode || { available: false };
                
                if (!sourceCode1.available || !sourceCode2.available) {
                    return {
                        textSimilarity: 0,
                        structuralSimilarity: 0,
                        signatureSimilarity: 0,
                        overallSimilarity: 0,
                        analysisDetails: {
                            reason: 'source_code_unavailable',
                            method1Available: sourceCode1.available,
                            method2Available: sourceCode2.available
                        }
                    };
                }

                // „ÉÜ„Ç≠„Çπ„ÉàÈ°û‰ººÂ∫¶Ôºà„É¨„Éº„Éô„É≥„Ç∑„É•„Çø„Ç§„É≥Ë∑ùÈõ¢„Éô„Éº„ÇπÔºâ
                const textSimilarity = this.calculateTextSimilarity(
                    sourceCode1.cleaned, 
                    sourceCode2.cleaned
                );

                // ÊßãÈÄ†ÁöÑÈ°û‰ººÂ∫¶ÔºàË°åÊï∞„ÄÅÈï∑„Åï„Å™„Å©„ÅÆÊßãÈÄ†ÁöÑÁâπÂæ¥Ôºâ
                const structuralSimilarity = this.calculateStructuralSimilarity(
                    sourceCode1,
                    sourceCode2
                );

                // „Ç∑„Ç∞„Éç„ÉÅ„É£È°û‰ººÂ∫¶
                const signatureSimilarity = this.calculateSignatureSimilarity(
                    sourceCode1.signature,
                    sourceCode2.signature
                );

                // Á∑èÂêàÈ°û‰ººÂ∫¶ÔºàÈáç„Åø‰ªò„ÅëÂπ≥ÂùáÔºâ
                const overallSimilarity = Math.round(
                    (textSimilarity * 0.5) + 
                    (structuralSimilarity * 0.3) + 
                    (signatureSimilarity * 0.2)
                );

                return {
                    textSimilarity: Math.round(textSimilarity),
                    structuralSimilarity: Math.round(structuralSimilarity),
                    signatureSimilarity: Math.round(signatureSimilarity),
                    overallSimilarity,
                    analysisDetails: {
                        method1Length: sourceCode1.length,
                        method2Length: sourceCode2.length,
                        method1Lines: sourceCode1.lines,
                        method2Lines: sourceCode2.lines,
                        method1Signature: sourceCode1.signature,
                        method2Signature: sourceCode2.signature
                    }
                };
            }

            // **Êñ∞Ê©üËÉΩ**: „ÉÜ„Ç≠„Çπ„ÉàÈ°û‰ººÂ∫¶Ë®àÁÆóÔºàÁ∞°Áï•Âåñ„Åï„Çå„Åü„É¨„Éº„Éô„É≥„Ç∑„É•„Çø„Ç§„É≥Ë∑ùÈõ¢Ôºâ
            calculateTextSimilarity(text1, text2) {
                if (text1 === text2) return 100;
                if (!text1 || !text2) return 0;

                // Áü≠„ÅÑÊñπ„Å´Âêà„Çè„Åõ„Å¶Ê≠£Ë¶èÂåñ
                const maxLength = Math.max(text1.length, text2.length);
                if (maxLength === 0) return 100;

                // Á∞°Âçò„Å™ÊñáÂ≠óÂàóÈ°û‰ººÂ∫¶Ë®àÁÆóÔºàÂäπÁéáÁöÑ„Å™Ëøë‰ººÔºâ
                const distance = this.levenshteinDistance(text1, text2);
                const similarity = Math.max(0, (maxLength - distance) / maxLength * 100);
                
                return similarity;
            }

            // **Êñ∞Ê©üËÉΩ**: ÊßãÈÄ†ÁöÑÈ°û‰ººÂ∫¶Ë®àÁÆó
            calculateStructuralSimilarity(source1, source2) {
                const lengthSimilarity = this.compareLengths(source1.length, source2.length);
                const linesSimilarity = this.compareLengths(source1.lines, source2.lines);
                
                // ÊßãÈÄ†ÁöÑÁâπÂæ¥„ÅÆÈ°û‰ººÂ∫¶
                return (lengthSimilarity + linesSimilarity) / 2;
            }

            // **Êñ∞Ê©üËÉΩ**: „Ç∑„Ç∞„Éç„ÉÅ„É£È°û‰ººÂ∫¶Ë®àÁÆó
            calculateSignatureSimilarity(signature1, signature2) {
                if (signature1 === signature2) return 100;
                if (!signature1 || !signature2) return 0;

                // „Éë„É©„É°„Éº„ÇøÊï∞„ÅÆÊØîËºÉ
                const params1 = this.extractParameters(signature1);
                const params2 = this.extractParameters(signature2);
                
                if (params1.length === params2.length) {
                    if (params1.length === 0) return 100; // ‰∏°Êñπ„Å®„ÇÇ„Éë„É©„É°„Éº„Çø„Å™„Åó
                    
                    // „Éë„É©„É°„Éº„ÇøÂêç„ÅÆÈ°û‰ººÂ∫¶
                    let paramSimilarity = 0;
                    for (let i = 0; i < params1.length; i++) {
                        if (params1[i] === params2[i]) {
                            paramSimilarity += 100;
                        } else if (params1[i] && params2[i]) {
                            // ÈÉ®ÂàÜÁöÑ„Å™È°û‰ººÂ∫¶
                            paramSimilarity += this.calculateTextSimilarity(params1[i], params2[i]) * 0.5;
                        }
                    }
                    return paramSimilarity / params1.length;
                }
                
                // „Éë„É©„É°„Éº„ÇøÊï∞„ÅåÁï∞„Å™„ÇãÂ†¥Âêà„ÅØ‰Ωé„ÅÑÈ°û‰ººÂ∫¶
                return Math.max(0, 50 - Math.abs(params1.length - params2.length) * 10);
            }

            // **Ë£úÂä©Èñ¢Êï∞**: Êï∞ÂÄ§„ÅÆÈ°û‰ººÂ∫¶ÊØîËºÉ
            compareLengths(len1, len2) {
                if (len1 === len2) return 100;
                const maxLen = Math.max(len1, len2);
                const minLen = Math.min(len1, len2);
                if (maxLen === 0) return 100;
                return (minLen / maxLen) * 100;
            }

            // **Ë£úÂä©Èñ¢Êï∞**: „Éë„É©„É°„Éº„ÇøÊäΩÂá∫
            extractParameters(signature) {
                try {
                    const paramMatch = signature.match(/\(([^)]*)\)/);
                    if (paramMatch && paramMatch[1]) {
                        return paramMatch[1]
                            .split(',')
                            .map(param => param.trim())
                            .filter(param => param.length > 0);
                    }
                    return [];
                } catch {
                    return [];
                }
            }

            // **Ë£úÂä©Èñ¢Êï∞**: Á∞°Áï•Âåñ„Åï„Çå„Åü„É¨„Éº„Éô„É≥„Ç∑„É•„Çø„Ç§„É≥Ë∑ùÈõ¢
            levenshteinDistance(str1, str2) {
                // ÂäπÁéáÂåñ„ÅÆ„Åü„ÇÅ„ÄÅÈï∑„ÅÑÊñáÂ≠óÂàó„ÅØÂàá„ÇäË©∞„ÇÅ
                const maxLength = 1000;
                const s1 = str1.substring(0, maxLength);
                const s2 = str2.substring(0, maxLength);
                
                const matrix = Array(s2.length + 1).fill(null).map(() => Array(s1.length + 1).fill(null));

                for (let i = 0; i <= s1.length; i++) matrix[0][i] = i;
                for (let j = 0; j <= s2.length; j++) matrix[j][0] = j;

                for (let j = 1; j <= s2.length; j++) {
                    for (let i = 1; i <= s1.length; i++) {
                        const indicator = s1[i - 1] === s2[j - 1] ? 0 : 1;
                        matrix[j][i] = Math.min(
                            matrix[j][i - 1] + 1,     // deletion
                            matrix[j - 1][i] + 1,     // insertion
                            matrix[j - 1][i - 1] + indicator   // substitution
                        );
                    }
                }

                return matrix[s2.length][s1.length];
            }

            // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„É¨„Éô„É´„ÅÆÂà§ÂÆö
            getSimilarityLevel(similarity) {
                if (similarity >= 90) return { level: 'high', icon: 'üî¥', label: 'È´ò„ÅÑÈ°û‰ººÂ∫¶', color: '#dc3545' };
                if (similarity >= 70) return { level: 'medium', icon: 'üü°', label: '‰∏≠Á®ãÂ∫¶„ÅÆÈ°û‰ººÂ∫¶', color: '#ffc107' };
                if (similarity >= 50) return { level: 'low', icon: 'üü¢', label: '‰Ωé„ÅÑÈ°û‰ººÂ∫¶', color: '#28a745' };
                return { level: 'minimal', icon: '‚ö™', label: 'ÊúÄÂ∞èÈôê„ÅÆÈ°û‰ººÂ∫¶', color: '#6c757d' };
            }

            // **Ë£úÂä©Èñ¢Êï∞**: HTML„Ç®„Çπ„Ç±„Éº„Éó
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            guessFilename(className) {
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂêç„Åã„Çâ„Éï„Ç°„Ç§„É´Âêç„ÇíÊé®Ê∏¨ÔºàÂÆüÈöõ„Å´Â≠òÂú®„Åô„Çã„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÔºâ
                if (className === 'Window') {
                    return 'browser-builtin';
                }
                
                // inspector „ÅØÁµ±ÂêàÁâà„ÅÆHTML„Éï„Ç°„Ç§„É´ÂÜÖ„ÅßÂÆöÁæ©
                if (className === 'inspector' || className === 'UniversalMethodInspector') {
                    return 'universal-debug-test.html';
                }
                
                // ÂÆüÈöõ„Å´Â≠òÂú®„Åô„Çã„Éï„Ç°„Ç§„É´„Å®„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞
                const fileMapping = {
                    'workflowEditor': 'workflow-editor.js',
                    'WorkflowEditor': 'workflow-editor.js',
                    'uiManager': 'ui-manager.js',
                    'UIManager': 'ui-manager.js',
                    'connectionManager': 'connection-manager.js',
                    'ConnectionManager': 'connection-manager.js',
                    'nodeManager': 'node-manager.js',
                    'NodeManager': 'node-manager.js',
                    'eventHandler': 'event-handlers.js',
                    'EventHandler': 'event-handlers.js',
                    'eventHandlers': 'event-handlers.js',
                    'debugMonitor': 'debug-monitor.js',
                    'DebugMonitor': 'debug-monitor.js',
                    'workflowExecutor': 'workflow-executor.js',
                    'WorkflowExecutor': 'workflow-executor.js',
                    'llm': 'llm.js',
                    'LLM': 'llm.js'
                };
                
                // Áõ¥Êé•„Éû„ÉÉ„Éî„É≥„Ç∞„Åå„ÅÇ„ÇãÂ†¥Âêà
                if (fileMapping[className]) {
                    return fileMapping[className];
                }
                
                // **Êõ¥Êñ∞**: „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂÜÖ„ÅÆÂÆüÈöõ„ÅÆJS„Éï„Ç°„Ç§„É´ÔºàÁèæÂú®„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†„Å´Âü∫„Å•„ÅèÔºâ
                const existingFiles = [
                    'workflow-editor.js',
                    'event-handlers.js', 
                    'ui-manager.js',
                    'connection-manager.js',
                    'node-manager.js',
                    'debug-monitor.js',
                    'workflow-executor.js',
                    'llm.js',
                    'universal-method-inspector.js',
                    'universal-debug-test.html' // „Åì„ÅÆÁµ±ÂêàHTML„Éï„Ç°„Ç§„É´Ëá™‰Ωì„ÇÇÂê´„ÇÅ„Çã
                ];
                
                // „Ç≠„É£„É°„É´„Ç±„Éº„Çπ„Çí„Ç±„Éê„Éñ„Ç±„Éº„Çπ„Å´Â§âÊèõ
                const kebabCase = className
                    .replace(/([a-z])([A-Z])/g, '$1-$2')
                    .toLowerCase();
                
                const guessedFile = `${kebabCase}.js`;
                
                // Êé®Ê∏¨„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÅåÂÆüÈöõ„Å´Â≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (existingFiles.includes(guessedFile)) {
                    return guessedFile;
                }
                
                // Â≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ null „ÇíËøî„ÅôÔºàÈô§Â§ñÂØæË±°Ôºâ
                return null;
            }

            scanWindowObject(methodsArray) {
                const windowMethods = [];
                for (const key in window) {
                    try {
                        if (typeof window[key] === 'function' && 
                            !key.startsWith('webkit') && 
                            !key.startsWith('chrome') &&
                            (!this.excludePrivate || !key.startsWith('_'))) {
                            windowMethods.push({
                                name: key,
                                className: 'Window',
                                fullPath: `window.${key}`,
                                filename: 'browser-builtin',
                                discovered: Date.now()
                            });
                        }
                    } catch (e) {
                        // „Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Å™„ÅÑ„Éó„É≠„Éë„ÉÜ„Ç£„Çí„Çπ„Ç≠„ÉÉ„Éó
                    }
                }
                
                // ‰∏ä‰Ωç50ÂÄã„Åæ„Åß„Å´Âà∂Èôê
                methodsArray.push(...windowMethods.slice(0, 50));
            }

            generateDisplay() {
                console.log('üîç generateDisplay called - Current mode:', window.currentMode || 'methods');
                
                if (window.currentMode === 'duplicates') {
                    this.generateDuplicateAnalysisDisplay();
                } else {
                    this.generateMethodDisplay();
                }
            }

            generateMethodDisplay() {
                console.log('üìã Generating Method Detection display');
                const resultsContainer = document.getElementById('resultsContainer');
                if (!resultsContainer) return;

                if (this.discoveredMethods.size === 0) {
                    resultsContainer.innerHTML = this.getEmptyStateHTML();
                    return;
                }

                let html = '<div style="margin-bottom: 15px; padding: 10px; background: #e7f3ff; border-radius: 6px; border-left: 4px solid #007bff;">';
                html += '<strong>üìã Method Detection Mode:</strong> Showing all detected methods grouped by file.';
                html += '</div>';

                // „Éï„Ç°„Ç§„É´Âêç„Åß„É°„ÇΩ„ÉÉ„Éâ„Çí„Ç∞„É´„Éº„ÉóÂåñÔºà.js„Å®.html„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÔºâ
                const methodsByFile = new Map();
                this.discoveredMethods.forEach(method => {
                    // **‰øÆÊ≠£**: null„ÅÆÂ†¥Âêà„ÅÆÂÆâÂÖ®„Å™Âá¶ÁêÜ
                    let filename = method.filename;
                    if (!filename || filename === null) {
                        filename = 'unknown-source';
                    }
                    
                    // **Êñ∞Ê©üËÉΩ**: .js„Å®.html„Éï„Ç°„Ç§„É´„ÅÆ„Åø„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
                    if (!this.isValidFileExtension(filename)) {
                        return; // .js/.html‰ª•Â§ñ„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Çπ„Ç≠„ÉÉ„Éó
                    }
                    
                    if (!methodsByFile.has(filename)) {
                        methodsByFile.set(filename, []);
                    }
                    methodsByFile.get(filename).push(method);
                });

                // „Éï„Ç°„Ç§„É´Âêç„Åß„ÇΩ„Éº„ÉàÔºà„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÔºâ
                const sortedFiles = Array.from(methodsByFile.keys()).sort((a, b) => {
                    // universal-debug-test.html „ÇíÊúÄÂæå„Å´Ë°®Á§∫
                    if (a.includes('universal-debug-test.html')) return 1;
                    if (b.includes('universal-debug-test.html')) return -1;
                    return a.localeCompare(b);
                });

                // „Éï„Ç°„Ç§„É´„Åî„Å®„Å´„Çª„ÇØ„Ç∑„Éß„É≥Ë°®Á§∫
                sortedFiles.forEach(filename => {
                    const methods = methodsByFile.get(filename);
                    // **‰øÆÊ≠£**: filename„ÅÆÂÆâÂÖ®„Å™Âá¶ÁêÜ
                    const safeFilename = filename || 'unknown-source';
                    const fileIcon = this.getFileIcon(safeFilename);
                    const fileColor = this.getFileColor(safeFilename);
                    
                    html += `
                        <div style="margin-bottom: 25px; border: 1px solid #e9ecef; border-radius: 8px; overflow: hidden;">
                            <div style="background: ${fileColor}; color: white; padding: 12px 20px; font-weight: 600; display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center;">
                                    <span style="margin-right: 8px; font-size: 1.2em;">${fileIcon}</span>
                                    <span>${safeFilename}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="background: rgba(255,255,255,0.2); padding: 3px 10px; border-radius: 12px; font-size: 0.9em;">
                                        ${methods.length} methods
                                    </span>
                                    <!-- **Êñ∞Ê©üËÉΩ**: „Éï„Ç°„Ç§„É´Âçò‰Ωç„ÉÜ„Çπ„Éà„Éú„Çø„É≥ -->
                                    <button onclick="testFileExecution('${safeFilename}')" 
                                            style="background: rgba(255,255,255,0.3); color: white; border: 1px solid rgba(255,255,255,0.5); padding: 4px 12px; border-radius: 4px; font-size: 0.8em; cursor: pointer; font-weight: bold;">
                                        üß™ „Éï„Ç°„Ç§„É´‰∏ÄÊã¨„ÉÜ„Çπ„Éà
                                    </button>
                                </div>
                            </div>
                            <div style="padding: 15px; background: #f8f9fa;">
                                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;">
                    `;

                    methods.forEach(method => {
                        html += `
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; border-left: 3px solid #28a745;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                    <div style="font-weight: 600; font-size: 1.0em; color: #2c3e50;">${method.name}</div>
                                    <div style="font-size: 1.1em; color: #28a745;">‚úì</div>
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.85em; color: #6c757d;">
                                    <div style="font-family: monospace; background: #f8f9fa; padding: 1px 5px; border-radius: 3px;">${method.className}</div>
                                    <div>${new Date(method.discovered).toLocaleTimeString()}</div>
                                </div>
                            </div>
                        `;
                    });

                    html += '</div></div></div>';
                });
                
                resultsContainer.innerHTML = html;
            }

            getFileIcon(filename) {
                // **‰øÆÊ≠£**: null„ÉÅ„Çß„ÉÉ„ÇØ„ÇíËøΩÂä†
                if (!filename || filename === null) return '‚ùì';
                if (filename === 'browser-builtin') return 'üåê';
                if (filename === 'unknown-source') return '‚ùì';
                if (filename.includes('workflow')) return '‚ö°';
                if (filename.includes('ui')) return 'üé®';
                if (filename.includes('connection')) return 'üîó';
                if (filename.includes('node')) return 'üì¶';
                if (filename.includes('event')) return 'üéØ';
                if (filename.includes('debug')) return 'üêõ';
                if (filename.includes('llm')) return 'ü§ñ';
                return 'üìÑ';
            }

            getFileColor(filename) {
                // **‰øÆÊ≠£**: null„ÉÅ„Çß„ÉÉ„ÇØ„ÇíËøΩÂä†
                if (!filename || filename === null) return '#dc3545';
                if (filename === 'browser-builtin') return '#6c757d';
                if (filename === 'unknown-source') return '#dc3545';
                if (filename.includes('workflow')) return '#007bff';
                if (filename.includes('ui')) return '#28a745';
                if (filename.includes('connection')) return '#17a2b8';
                if (filename.includes('node')) return '#6f42c1';
                if (filename.includes('event')) return '#fd7e14';
                if (filename.includes('debug')) return '#e83e8c';
                if (filename.includes('llm')) return '#20c997';
                return '#495057';
            }

            // **Êñ∞Ê©üËÉΩ**: „Éï„Ç°„Ç§„É´Êã°ÂºµÂ≠ê„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            isValidFileExtension(filename) {
                if (!filename || filename === null) return false;
                if (filename === 'browser-builtin' || filename === 'unknown-source') return false;
                
                // .js„Å®.html„Éï„Ç°„Ç§„É´„ÅÆ„Åø„ÇíË®±ÂèØ
                return filename.endsWith('.js') || filename.endsWith('.html');
            }

            generateDuplicateAnalysisDisplay() {
                console.log('üîç Generating Duplicate Analysis display');
                const resultsContainer = document.getElementById('resultsContainer');
                if (!resultsContainer) return;

                if (this.discoveredMethods.size === 0) {
                    resultsContainer.innerHTML = this.getEmptyStateHTML();
                    return;
                }

                // ÈáçË§áÂàÜÊûê„ÇíÂÆüË°å
                const duplicateGroups = this.analyzeDuplicates();
                
                let html = '<div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">';
                html += '<strong>üîç Duplicate Analysis Mode:</strong> Showing methods with the same name across different objects.';
                
                // **Êñ∞Ê©üËÉΩ**: „Éï„Ç£„É´„Çø„ÉºÊÉÖÂ†±„ÅÆË°®Á§∫
                html += `<br><small style="color: #856404;">üìÅ „Éï„Ç°„Ç§„É´„Éï„Ç£„É´„Çø„Éº: .js „Å® .html „Éï„Ç°„Ç§„É´„ÅÆ„ÅøË°®Á§∫</small>`;
                if (this.similarityThreshold && this.similarityThreshold > 0) {
                    html += `<br><small style="color: #856404;">üìä È°û‰ººÂ∫¶„Éï„Ç£„É´„Çø„Éº: ${this.similarityThreshold}% ‰ª•‰∏ä„ÅÆ„ÅøË°®Á§∫</small>`;
                }
                
                html += '</div>';

                if (duplicateGroups.length === 0) {
                    html += `
                        <div style="text-align: center; padding: 40px; color: #6c757d;">
                            <div style="font-size: 3em; margin-bottom: 15px;">‚ú®</div>
                            <h3>No Duplicate Methods Found</h3>
                            <p>All method names are unique across scanned .js and .html files.</p>
                            <small style="color: #999; margin-top: 10px; display: block;">
                                üìÅ Only .js and .html files are analyzed for duplicates
                            </small>
                        </div>
                    `;
                } else {
                    html += '<div style="display: flex; flex-direction: column; gap: 20px;">';
                    
                    duplicateGroups.forEach(group => {
                        const duplicateTypeColor = this.getDuplicateTypeColor(group.duplicateType);
                        const duplicateTypeLabel = this.getDuplicateTypeLabel(group.duplicateType);
                        
                        // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶ÊÉÖÂ†±„ÅÆÂèñÂæó
                        const similarityInfo = group.similarityAnalysis || {};
                        const similarityLevel = similarityInfo.level || { icon: '‚ùì', label: 'ÂàÜÊûê‰∏çÂèØ', color: '#6c757d' };
                        const averageSimilarity = similarityInfo.averageSimilarity || 0;
                        
                        html += `
                            <div style="background: white; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; border-left: 4px solid ${duplicateTypeColor};">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: ${duplicateTypeColor}; margin: 0;">üîÑ ${group.methodName}</h4>
                                    <div style="display: flex; gap: 8px; align-items: center;">
                                        <span style="background: ${duplicateTypeColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em;">
                                            ${duplicateTypeLabel}
                                        </span>
                                        <span style="background: ${similarityLevel.color}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.8em;">
                                            ${similarityLevel.icon} ${averageSimilarity}% È°û‰ººÂ∫¶
                                        </span>
                                        <span style="background: #6c757d; color: white; padding: 4px 12px; border-radius: 20px; font-size: 0.9em;">
                                            ${group.methods.length} duplicates
                                        </span>
                                    </div>
                                </div>
                                
                                <!-- **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Çµ„Éû„É™„ÉºË°®Á§∫ -->
                                ${similarityInfo.summary ? `
                                <div style="background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                        <span style="font-size: 1.2em;">${similarityLevel.icon}</span>
                                        <strong style="color: ${similarityLevel.color};">${similarityLevel.label}</strong>
                                    </div>
                                    <div style="font-size: 0.9em; color: #495057;">${similarityInfo.summary}</div>
                                    ${similarityInfo.pairCount > 0 ? `
                                    <div style="margin-top: 8px; font-size: 0.8em; color: #6c757d;">
                                        Ë©≥Á¥∞: ÊúÄÂ§ß ${similarityInfo.maxSimilarity}% / ÊúÄÂ∞è ${similarityInfo.minSimilarity}% / ${similarityInfo.pairCount} „Éö„Ç¢ÂàÜÊûêÊ∏à„Åø
                                    </div>
                                    ` : ''}
                                </div>
                                ` : ''}
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px;">
                        `;
                        
                        group.methods.forEach((method, index) => {
                            // **‰øÆÊ≠£**: filename„ÅÆÂÆâÂÖ®„Å™Âá¶ÁêÜ„Å®„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
                            const safeFilename = method.filename || 'unknown-source';
                            
                            // **ËøΩÂä†„Éï„Ç£„É´„Çø„É™„É≥„Ç∞**: .js/.html‰ª•Â§ñ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„Çí„Çπ„Ç≠„ÉÉ„Éó
                            if (!this.isValidFileExtension(safeFilename)) {
                                return; // .js/.html‰ª•Â§ñ„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Çπ„Ç≠„ÉÉ„Éó
                            }
                            
                            const fileIcon = this.getFileIcon(safeFilename);
                            const fileColor = this.getFileColor(safeFilename);
                            
                            // **Êñ∞Ê©üËÉΩ**: ÂÄãÂà•„É°„ÇΩ„ÉÉ„ÉâÊÉÖÂ†±„ÅÆË°®Á§∫
                            const sourceInfo = method.sourceCode || { 
                                available: false, 
                                lines: 0, 
                                length: 0, 
                                signature: '', 
                                raw: '' 
                            };
                            const hasSourceCode = sourceInfo.available;
                            const methodId = `method_${group.methodName}_${method.className}_${index}`;
                            
                            html += `
                                <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; border-left: 3px solid ${fileColor};">
                                    <div style="font-weight: 600; color: #495057; margin-bottom: 4px;">${method.className}</div>
                                    <div style="font-size: 0.8em; color: #6c757d; font-family: monospace; margin-bottom: 6px; background: white; padding: 2px 6px; border-radius: 3px; border: 1px solid #e9ecef;">${method.fullPath}</div>
                                    
                                    <!-- **Êñ∞Ê©üËÉΩ**: „ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÊÉÖÂ†± -->
                                    ${hasSourceCode ? `
                                    <div style="margin: 6px 0; padding: 4px 6px; background: #e8f5e8; border-radius: 3px; font-size: 0.75em;">
                                        üìÑ ${sourceInfo.lines} Ë°å / ${sourceInfo.length} ÊñáÂ≠ó
                                        ${sourceInfo.signature ? `<br><code style="color: #2d6e2d;">${sourceInfo.signature}</code>` : ''}
                                    </div>
                                    ` : `
                                    <div style="margin: 6px 0; padding: 4px 6px; background: #fff3cd; border-radius: 3px; font-size: 0.75em; color: #856404;">
                                        ‚ö†Ô∏è „ÇΩ„Éº„Çπ„Ç≥„Éº„ÉâÂèñÂæó‰∏çÂèØ
                                    </div>
                                    `}
                                    
                                    <div style="display: flex; align-items: center; justify-content: space-between; font-size: 0.75em; color: #6c757d;">
                                        <div style="display: flex; align-items: center;">
                                            <span style="margin-right: 4px; font-size: 1.1em;">${fileIcon}</span>
                                            <span style="font-family: monospace; background: #e7f3ff; padding: 2px 6px; border-radius: 3px; color: #0066cc;">${safeFilename}</span>
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            ${hasSourceCode ? `
                                            <button onclick="toggleCodeView('${methodId}')" style="padding: 2px 6px; background: #007bff; color: white; border: none; border-radius: 3px; font-size: 0.7em; cursor: pointer;">
                                                üìñ „Ç≥„Éº„ÉâË°®Á§∫
                                            </button>
                                            ` : ''}
                                            <span style="font-size: 0.7em; color: #999;">${new Date(method.discovered).toLocaleTimeString()}</span>
                                        </div>
                                    </div>
                                    
                                    <!-- **Êñ∞Ê©üËÉΩ**: Èö†„Åï„Çå„Åü„Ç≥„Éº„ÉâË°®Á§∫„Ç®„É™„Ç¢ -->
                                    ${hasSourceCode ? `
                                    <div id="${methodId}" style="display: none; margin-top: 8px; padding: 8px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;">
                                        <div style="font-size: 0.8em; color: #495057; margin-bottom: 4px;">
                                            <strong>${method.className}.${method.name}</strong> „ÅÆ„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ:
                                        </div>
                                        <pre style="font-size: 0.7em; background: #ffffff; padding: 8px; border-radius: 3px; overflow-x: auto; max-height: 200px; margin: 0; white-space: pre-wrap; word-break: break-all;">${this.escapeHtml(sourceInfo.raw)}</pre>
                                    </div>
                                    ` : ''}
                                </div>
                            `;
                        });
                        
                        html += '</div></div>';
                    });
                    
                    html += '</div>';
                }

                resultsContainer.innerHTML = html;
            }

            analyzeDuplicates() {
                console.log('üîç Analyzing duplicates from', this.discoveredMethods.size, 'methods');
                
                // „É°„ÇΩ„ÉÉ„ÉâÂêç„Åß„Ç∞„É´„Éº„ÉóÂåñÔºà.js„Å®.html„Éï„Ç°„Ç§„É´„ÅÆ„ÅøÔºâ
                const methodGroups = new Map();
                let filteredMethodCount = 0;
                let skippedMethodCount = 0;
                
                this.discoveredMethods.forEach(method => {
                    // **Êñ∞Ê©üËÉΩ**: .js„Å®.html„Éï„Ç°„Ç§„É´„ÅÆ„Åø„Çí„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
                    const filename = method.filename || 'unknown-source';
                    if (!this.isValidFileExtension(filename)) {
                        skippedMethodCount++;
                        return; // .js/.html‰ª•Â§ñ„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Çπ„Ç≠„ÉÉ„Éó
                    }
                    
                    filteredMethodCount++;
                    if (!methodGroups.has(method.name)) {
                        methodGroups.set(method.name, []);
                    }
                    methodGroups.get(method.name).push(method);
                });
                
                console.log(`üîç File extension filter: ${filteredMethodCount} methods included, ${skippedMethodCount} methods skipped (.js/.html only)`);
                console.log(`üîç Grouped into ${methodGroups.size} unique method names`);

                // **‰øÆÊ≠£**: „Çà„ÇäÊüîËªü„Å™ÈáçË§áÊ§úÂá∫„É≠„Ç∏„ÉÉ„ÇØ
                const duplicates = [];
                methodGroups.forEach((methods, methodName) => {
                    if (methods.length > 1) {
                        // **ÊîπÂñÑ**: ‰ª•‰∏ã„ÅÆ„ÅÑ„Åö„Çå„Åã„ÅÆÊù°‰ª∂„ÅßÈáçË§á„Å®„Åø„Å™„Åô
                        const uniqueClasses = new Set(methods.map(m => m.className));
                        const uniqueFiles = new Set(methods.map(m => m.filename));
                        const uniquePaths = new Set(methods.map(m => m.fullPath));
                        
                        // ÈáçË§áÊù°‰ª∂: Áï∞„Å™„Çã„ÇØ„É©„Çπ„ÄÅÁï∞„Å™„Çã„Éï„Ç°„Ç§„É´„ÄÅ„Åæ„Åü„ÅØÁï∞„Å™„Çã„Éï„É´„Éë„Çπ„ÇíÊåÅ„Å§
                        const isDuplicate = 
                            uniqueClasses.size > 1 ||  // Áï∞„Å™„Çã„ÇØ„É©„ÇπÂêç
                            uniqueFiles.size > 1 ||    // Áï∞„Å™„Çã„Éï„Ç°„Ç§„É´
                            uniquePaths.size > 1;      // Áï∞„Å™„Çã„Éï„É´„Éë„Çπ
                        
                        if (isDuplicate) {
                            // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶ÂàÜÊûê„ÇíÂÆüË°å
                            const similarityAnalysis = this.analyzeSimilarityForGroup(methods);
                            
                            duplicates.push({
                                methodName: methodName,
                                methods: methods,
                                count: methods.length,
                                duplicateType: this.getDuplicateType(methods),
                                similarityAnalysis: similarityAnalysis // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶ÊÉÖÂ†±ËøΩÂä†
                            });
                        }
                    }
                });

                // **‰øÆÊ≠£**: È°û‰ººÂ∫¶„ÅÆÈ´ò„ÅÑÈ†Ü„Å´„ÇΩ„Éº„ÉàÔºàÂêå„ÅòÈ°û‰ººÂ∫¶„ÅÆÂ†¥Âêà„ÅØÈáçË§áÊï∞„ÅÆÂ§ö„ÅÑÈ†ÜÔºâ
                duplicates.sort((a, b) => {
                    const similarityA = a.similarityAnalysis?.averageSimilarity || 0;
                    const similarityB = b.similarityAnalysis?.averageSimilarity || 0;
                    
                    // È°û‰ººÂ∫¶„ÅåÂêå„ÅòÂ†¥Âêà„ÅØÈáçË§áÊï∞„ÅßÊØîËºÉ
                    if (similarityA === similarityB) {
                        return b.count - a.count;
                    }
                    
                    // È°û‰ººÂ∫¶„ÅÆÈ´ò„ÅÑÈ†Ü
                    return similarityB - similarityA;
                });
                
                // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Åó„Åç„ÅÑÂÄ§„Å´„Çà„Çã„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
                let filteredDuplicates = duplicates;
                if (this.similarityThreshold && this.similarityThreshold > 0) {
                    filteredDuplicates = duplicates.filter(group => {
                        const averageSimilarity = group.similarityAnalysis?.averageSimilarity || 0;
                        return averageSimilarity >= this.similarityThreshold;
                    });
                    
                    console.log(`üîç Similarity filter applied: ${this.similarityThreshold}% threshold`);
                    console.log(`üîç Filtered from ${duplicates.length} to ${filteredDuplicates.length} groups`);
                }
                
                console.log('üîç Found', filteredDuplicates.length, 'duplicate method groups (sorted by similarity):');
                filteredDuplicates.forEach((group, index) => {
                    const similarity = group.similarityAnalysis?.averageSimilarity || 0;
                    console.log(`  ${index + 1}. ${group.methodName}(${group.count}) - ${similarity}% similarity`);
                });
                
                return filteredDuplicates;
            }

            // **Êñ∞Ê©üËÉΩ**: „Ç∞„É´„Éº„ÉóÂÜÖ„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÈñìÈ°û‰ººÂ∫¶ÂàÜÊûê
            analyzeSimilarityForGroup(methods) {
                console.log(`üî¨ Analyzing similarity for ${methods.length} methods named "${methods[0].name}"`);
                
                const pairAnalyses = [];
                let totalSimilarity = 0;
                let maxSimilarity = 0;
                let minSimilarity = 100;
                let pairCount = 0;

                // „Åô„Åπ„Å¶„ÅÆÂèØËÉΩ„Å™„Éö„Ç¢„Å´„Å§„ÅÑ„Å¶È°û‰ººÂ∫¶„ÇíË®àÁÆó
                for (let i = 0; i < methods.length; i++) {
                    for (let j = i + 1; j < methods.length; j++) {
                        const method1 = methods[i];
                        const method2 = methods[j];
                        
                        const similarity = this.analyzeCodeSimilarity(method1, method2);
                        
                        pairAnalyses.push({
                            method1: {
                                className: method1.className,
                                filename: method1.filename,
                                fullPath: method1.fullPath
                            },
                            method2: {
                                className: method2.className,
                                filename: method2.filename,
                                fullPath: method2.fullPath
                            },
                            similarity: similarity
                        });

                        if (similarity.overallSimilarity > 0) {
                            totalSimilarity += similarity.overallSimilarity;
                            maxSimilarity = Math.max(maxSimilarity, similarity.overallSimilarity);
                            minSimilarity = Math.min(minSimilarity, similarity.overallSimilarity);
                            pairCount++;
                        }
                    }
                }

                const averageSimilarity = pairCount > 0 ? Math.round(totalSimilarity / pairCount) : 0;
                
                // ÊúÄ„ÇÇÈ°û‰ººÂ∫¶„ÅÆÈ´ò„ÅÑ„Éö„Ç¢„ÇíÁâπÂÆö
                const highestSimilarityPair = pairAnalyses.reduce((highest, current) => {
                    return current.similarity.overallSimilarity > (highest?.similarity?.overallSimilarity || 0) 
                        ? current : highest;
                }, null);

                const result = {
                    averageSimilarity,
                    maxSimilarity,
                    minSimilarity,
                    pairCount,
                    highestSimilarityPair,
                    allPairs: pairAnalyses,
                    level: this.getSimilarityLevel(averageSimilarity),
                    summary: this.generateSimilaritySummary(averageSimilarity, pairCount, methods.length)
                };

                console.log(`üî¨ Similarity analysis for "${methods[0].name}":`, {
                    average: averageSimilarity,
                    max: maxSimilarity,
                    min: minSimilarity,
                    pairs: pairCount
                });

                return result;
            }

            // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Çµ„Éû„É™„ÉºÁîüÊàê
            generateSimilaritySummary(averageSimilarity, pairCount, methodCount) {
                if (pairCount === 0) {
                    return '„ÇΩ„Éº„Çπ„Ç≥„Éº„Éâ„ÅÆÊØîËºÉ„Åå„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
                }

                if (averageSimilarity >= 90) {
                    return `${methodCount}ÂÄã„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÈùûÂ∏∏„Å´È°û‰ºº„Åó„Å¶„ÅÑ„Åæ„Åô (Âπ≥Âùá ${averageSimilarity}%)`;
                } else if (averageSimilarity >= 70) {
                    return `${methodCount}ÂÄã„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÈ°û‰ºº„Åó„ÅüÂÆüË£Ö„Åß„Åô (Âπ≥Âùá ${averageSimilarity}%)`;
                } else if (averageSimilarity >= 50) {
                    return `${methodCount}ÂÄã„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÈÉ®ÂàÜÁöÑ„Å´È°û‰ºº„Åó„Å¶„ÅÑ„Åæ„Åô (Âπ≥Âùá ${averageSimilarity}%)`;
                } else {
                    return `${methodCount}ÂÄã„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÂêçÂâç„ÅÆ„ÅøÂêå„Åò„ÅßÂÆüË£Ö„ÅØÁï∞„Å™„Çä„Åæ„Åô (Âπ≥Âùá ${averageSimilarity}%)`;
                }
            }

            getDuplicateType(methods) {
                const uniqueClasses = new Set(methods.map(m => m.className));
                const uniqueFiles = new Set(methods.map(m => m.filename));
                
                if (uniqueClasses.size > 1 && uniqueFiles.size > 1) {
                    return 'cross-class-file';
                } else if (uniqueClasses.size > 1) {
                    return 'cross-class';
                } else if (uniqueFiles.size > 1) {
                    return 'cross-file';
                } else {
                    return 'same-object';
                }
            }

            getDuplicateTypeColor(duplicateType) {
                const colors = {
                    'cross-class-file': '#dc3545',  // Ëµ§: ÊúÄ„ÇÇÊ∑±Âàª
                    'cross-class': '#fd7e14',       // „Ç™„É¨„É≥„Ç∏: ÈáçË¶Å
                    'cross-file': '#ffc107',        // ÈªÑ: Ê≥®ÊÑè
                    'same-object': '#17a2b8'        // Èùí: ÊÉÖÂ†±
                };
                return colors[duplicateType] || '#6c757d';
            }

            getDuplicateTypeLabel(duplicateType) {
                const labels = {
                    'cross-class-file': 'Áï∞„Å™„Çã„ÇØ„É©„Çπ„Éª„Éï„Ç°„Ç§„É´',
                    'cross-class': 'Áï∞„Å™„Çã„ÇØ„É©„Çπ',
                    'cross-file': 'Áï∞„Å™„Çã„Éï„Ç°„Ç§„É´',
                    'same-object': 'Âêå„Åò„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà'
                };
                return labels[duplicateType] || 'Unknown';
            }

            updateStatistics() {
                const totalElement = document.getElementById('totalMethods');
                const lastScanElement = document.getElementById('lastScanTime');

                if (totalElement) totalElement.textContent = this.discoveredMethods.size;
                if (lastScanElement) lastScanElement.textContent = new Date().toLocaleTimeString();
            }

            clearData() {
                this.discoveredMethods.clear();
                this.generateDisplay();
                this.updateStatistics();
                this.showToast('All data cleared', 'info');
            }

            showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                document.body.appendChild(toast);

                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(toast)) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, 3000);
            }

            getEmptyStateHTML() {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">üîç</div>
                        <h3>No Methods Detected</h3>
                        <p>Click "Scan" to detect methods in your JavaScript objects.</p>
                        <button class="btn btn-primary" onclick="manualScan()" style="margin-top: 15px;">
                            üîç Start Scan
                        </button>
                    </div>
                `;
            }
        }

        // „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
        window.inspector = new UniversalMethodInspector();
        console.log('UniversalMethodInspector instance created and attached to window (integrated)');

        // ÁèæÂú®„ÅÆ„É¢„Éº„Éâ
        let currentMode = 'methods';



        function switchMode(mode) {
            console.log('üîÑ switchMode called with mode:', mode, '(previous mode:', window.currentMode || 'undefined', ')');
            console.log('üîç Available methods:', window.inspector ? window.inspector.discoveredMethods.size : 'Inspector not available');
            
            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„ÇíÊõ¥Êñ∞
            window.currentMode = mode;
            currentMode = mode; // „É≠„Éº„Ç´„É´Â§âÊï∞„ÇÇÊõ¥Êñ∞
            
            // **Êñ∞Ê©üËÉΩ**: „É¢„Éº„Éâ„ÇílocalStorage„Å´‰øùÂ≠ò
            try {
                localStorage.setItem('universalMethodInspector_currentMode', mode);
                console.log('üíæ Mode saved to localStorage:', mode);
            } catch (error) {
                console.warn('‚ö†Ô∏è Failed to save mode to localStorage:', error);
            }
            
            // „Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
            const methodBtn = document.getElementById('methodMode');
            const duplicateBtn = document.getElementById('duplicateMode');
            
            if (methodBtn) {
                methodBtn.classList.toggle('active', mode === 'methods');
                console.log('üìã Method Detection button active:', mode === 'methods');
            }
            if (duplicateBtn) {
                duplicateBtn.classList.toggle('active', mode === 'duplicates');
                console.log('üîç Duplicate Analysis button active:', mode === 'duplicates');
            }
            
            // „Çø„Ç§„Éà„É´„ÇíÊõ¥Êñ∞
            const sectionTitle = document.getElementById('sectionTitle');
            if (sectionTitle) {
                if (mode === 'methods') {
                    sectionTitle.textContent = 'üìã Method Detection Results';
                    console.log('üìã Switching to Method Detection mode');
                } else {
                    sectionTitle.textContent = 'üîç Duplicate Analysis Results';
                    console.log('üîç Switching to Duplicate Analysis mode');
                }
            }
            
            // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Éï„Ç£„É´„Çø„Éº„ÅÆË°®Á§∫/ÈùûË°®Á§∫Âàá„ÇäÊõø„Åà
            const similarityFilter = document.getElementById('similarityFilter');
            if (similarityFilter) {
                similarityFilter.style.display = mode === 'duplicates' ? 'block' : 'none';
            }
            
            // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Åó„Åç„ÅÑÂÄ§„ÅÆÂàùÊúüÂåñ
            if (mode === 'duplicates' && window.inspector) {
                if (!window.inspector.similarityThreshold) {
                    window.inspector.similarityThreshold = 0; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
                }
            }
            
            // **Âº∑Âåñ„Éá„Éê„ÉÉ„Ç∞**: ÈáçË§áÂàÜÊûê„ÅÆË©≥Á¥∞„É≠„Ç∞
            if (mode === 'duplicates' && window.inspector) {
                console.log('üîç DEBUG: Starting duplicate analysis...');
                console.log('üîç Total methods available:', window.inspector.discoveredMethods.size);
                
                // ÊâãÂãï„ÅßÈáçË§áÂàÜÊûê„Çí„ÉÜ„Çπ„Éà
                const duplicates = window.inspector.analyzeDuplicates();
                console.log('üîç Duplicate analysis result:', duplicates);
                
                if (duplicates.length === 0) {
                    console.log('‚ö†Ô∏è No duplicates found. Method names:');
                    const methodNames = Array.from(window.inspector.discoveredMethods.values()).map(m => m.name);
                    console.log('üîç Method names:', methodNames);
                    
                    // „Ç∞„É´„Éº„ÉóÂåñ„ÇíÊâãÂãïÁ¢∫Ë™ç
                    const groups = new Map();
                    window.inspector.discoveredMethods.forEach(method => {
                        if (!groups.has(method.name)) {
                            groups.set(method.name, []);
                        }
                        groups.get(method.name).push(method);
                    });
                    
                    console.log('üîç Method groups:', Array.from(groups.entries()).map(([name, methods]) => `${name}: ${methods.length} instances`));
                }
            }
            
            // Ë°®Á§∫„ÇíÊõ¥Êñ∞
            if (window.inspector && window.inspector.generateDisplay) {
                console.log('üîÑ Refreshing display for mode:', mode);
                window.inspector.generateDisplay();
                } else {
                console.warn('‚ö†Ô∏è Inspector or generateDisplay not available');
            }
        }

        // „Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞

        async function manualScan() {
            if (window.inspector) {
                await window.inspector.scanForMethods();
            }
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all detected data?')) {
                if (window.inspector) {
                    window.inspector.clearData();
                    }
                }
            }

        function exportData() {
            try {
                if (!window.inspector) {
                    alert('Inspector not available');
                    return;
                }

                const methods = Array.from(window.inspector.discoveredMethods.values());
                const data = {
                    timestamp: new Date().toISOString(),
                    totalMethods: window.inspector.discoveredMethods.size,
                    targetObjects: Array.from(window.inspector.targetObjects),
                    methods: methods.map(method => ({
                        name: method.name,
                        className: method.className,
                        fullPath: method.fullPath,
                        filename: method.filename || 'unknown',
                        discovered: new Date(method.discovered).toISOString()
                    }))
                };
                
                const jsonString = JSON.stringify(data, null, 2);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `method-inspection-results-${timestamp}.json`;
                
                // Ë§áÊï∞„ÅÆÊñπÊ≥ï„Åß„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíË©¶Ë°å
                if (downloadViaDataURI(jsonString, filename)) {
                    window.inspector.showToast(`Exported ${data.methods.length} methods to ${filename}`, 'success');
                } else if (downloadViaBlob(jsonString, filename)) {
                    window.inspector.showToast(`Exported ${data.methods.length} methods to ${filename}`, 'success');
                } else {
                    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Å´Ë°®Á§∫
                    showDataInTextArea(jsonString, filename);
                    window.inspector.showToast('Download failed. Data displayed in text area for manual copy.', 'warning');
                }
                
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed: ' + error.message);
            }
        }

        function downloadViaDataURI(content, filename) {
            try {
                const dataURI = 'data:application/json;charset=utf-8,' + encodeURIComponent(content);
                const link = document.createElement('a');
                link.href = dataURI;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                return true;
            } catch (error) {
                console.warn('Data URI download failed:', error);
                return false;
            }
        }

        function downloadViaBlob(content, filename) {
            try {
                const blob = new Blob([content], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // URL„ÇíÂ∞ë„ÅóÈÅÖ„Çå„Å¶Ëß£Êîæ
                        setTimeout(() => {
                    try {
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.warn('Failed to revoke URL:', e);
                    }
                }, 1000);
                
                return true;
            } catch (error) {
                console.warn('Blob download failed:', error);
                return false;
            }
        }

        function showDataInTextArea(content, filename) {
            // Êó¢Â≠ò„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
            const existingTextArea = document.getElementById('exportTextArea');
            if (existingTextArea) {
                existingTextArea.remove();
            }

            // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Çí‰ΩúÊàê
            const textArea = document.createElement('textarea');
            textArea.id = 'exportTextArea';
            textArea.value = content;
            textArea.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 80%;
                height: 60%;
                z-index: 10000;
                background: white;
                border: 2px solid #007bff;
                border-radius: 8px;
                padding: 20px;
                font-family: monospace;
                font-size: 12px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            textArea.readOnly = true;

            // Èñâ„Åò„Çã„Éú„Çø„É≥„Çí‰ΩúÊàê
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚úï Close';
            closeButton.style.cssText = `
                position: fixed;
                top: calc(50% - 32%);
                right: calc(50% - 42%);
                z-index: 10001;
                background: #dc3545;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                font-weight: bold;
            `;
            closeButton.onclick = () => {
                textArea.remove();
                closeButton.remove();
                overlay.remove();
            };

            // „Ç™„Éº„Éê„Éº„É¨„Ç§„Çí‰ΩúÊàê
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            overlay.onclick = () => {
                textArea.remove();
                closeButton.remove();
                overlay.remove();
            };

            // Ë¶ÅÁ¥†„ÇíËøΩÂä†
            document.body.appendChild(overlay);
            document.body.appendChild(textArea);
            document.body.appendChild(closeButton);

            // „ÉÜ„Ç≠„Çπ„Éà„ÇíÈÅ∏Êäû
            textArea.select();
            textArea.focus();

            // „Ç≥„Éî„ÉºÁî®„ÅÆË™¨Êòé„ÇíË°®Á§∫
            const instruction = document.createElement('div');
            instruction.style.cssText = `
                position: fixed;
                top: calc(50% - 35%);
                left: 50%;
                transform: translateX(-50%);
                z-index: 10002;
                background: #28a745;
                color: white;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
                text-align: center;
            `;
            instruction.textContent = `üìã ${filename} - Press Ctrl+A then Ctrl+C to copy all data`;
            document.body.appendChild(instruction);

            // 5ÁßíÂæå„Å´Ë™¨Êòé„ÇíÂâäÈô§
            setTimeout(() => {
                if (instruction.parentNode) {
                    instruction.remove();
                }
            }, 5000);
        }

        function applyFilters() {
            // Ê§úÁ¥¢„Éï„Ç£„É´„ÇøÊ©üËÉΩ
            const searchTerm = document.getElementById('searchMethod')?.value.toLowerCase() || '';
            
            if (!searchTerm) {
                // Ê§úÁ¥¢„ÇØ„É™„Ç¢ÊôÇ„ÅØÂÖ®„Å¶Ë°®Á§∫
                if (window.inspector && window.inspector.generateDisplay) {
                    window.inspector.generateDisplay();
                            }
                return;
                }
                
            // Ê§úÁ¥¢ÁµêÊûú„Çí„Éï„Ç£„É´„ÇøË°®Á§∫
            const resultsContainer = document.getElementById('resultsContainer');
            if (resultsContainer) {
                // „É°„ÇΩ„ÉÉ„Éâ„Ç¢„Ç§„ÉÜ„É†„ÇíÊ§úÁ¥¢
                const methodDivs = resultsContainer.querySelectorAll('div[style*="background: white"][style*="border: 1px solid"]');
                methodDivs.forEach(div => {
                    // „É°„ÇΩ„ÉÉ„ÉâÂêç„ÇíÂèñÂæóÔºàfont-weight: 600„ÅÆdivÔºâ
                    const methodNameEl = div.querySelector('div[style*="font-weight: 600"]');
                    if (methodNameEl) {
                        const methodName = methodNameEl.textContent.toLowerCase();
                        if (methodName.includes(searchTerm)) {
                            div.style.display = '';
                            // „Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
                            methodNameEl.innerHTML = methodNameEl.textContent.replace(
                                new RegExp(`(${searchTerm})`, 'gi'),
                                '<mark style="background: yellow; padding: 1px 2px; border-radius: 2px;">$1</mark>'
                            );
            } else {
                            div.style.display = 'none';
                        }
                    }
                });
            }
        }

        function refreshDisplay() {
            if (window.inspector) {
                window.inspector.generateDisplay();
                window.inspector.showToast('Display refreshed', 'info');
            }
        }

        // **Êñ∞Ê©üËÉΩ**: „Ç≥„Éº„ÉâË°®Á§∫„Éà„Ç∞„É´Èñ¢Êï∞
        function toggleCodeView(methodId) {
            const codeElement = document.getElementById(methodId);
            if (codeElement) {
                const isVisible = codeElement.style.display !== 'none';
                codeElement.style.display = isVisible ? 'none' : 'block';
                
                // „Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÊõ¥Êñ∞
                const button = codeElement.previousElementSibling.querySelector('button[onclick*="' + methodId + '"]');
                if (button) {
                    button.textContent = isVisible ? 'üìñ „Ç≥„Éº„ÉâË°®Á§∫' : 'üîí „Ç≥„Éº„ÉâÈùûË°®Á§∫';
                }
            }
        }

        // **Êñ∞Ê©üËÉΩ**: È°û‰ººÂ∫¶„Éï„Ç£„É´„Çø„ÉºÊõ¥Êñ∞
        function updateSimilarityFilter(value) {
            document.getElementById('similarityValue').textContent = value + '%';
            
            // „Éï„Ç£„É´„Çø„ÉºÈÅ©Áî®ÔºàÈáçË§áÂàÜÊûê„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
            if (window.currentMode === 'duplicates' && window.inspector) {
                window.inspector.similarityThreshold = parseInt(value);
                window.inspector.generateDisplay();
            }
        }

        // **Êñ∞Ê©üËÉΩ**: „Éï„Ç°„Ç§„É´Âçò‰Ωç„Åß„ÅÆ‰∏ÄÊã¨„ÉÜ„Çπ„ÉàÂÆüË°å
        function testFileExecution(filename) {
            console.log(`üß™ Testing all methods in file: ${filename}`);
            
            if (!window.inspector || !window.inspector.discoveredMethods) {
                alert('Inspector not available');
                return;
            }
            
            // „Éï„Ç°„Ç§„É´„Å´Â±û„Åô„Çã„É°„ÇΩ„ÉÉ„Éâ„ÇíÂèñÂæó
            const fileMethods = Array.from(window.inspector.discoveredMethods.values())
                .filter(method => (method.filename || 'unknown-source') === filename);
            
            if (fileMethods.length === 0) {
                alert(`No methods found in ${filename}`);
                return;
            }
            
            // „ÉÜ„Çπ„ÉàÁµêÊûú„ÇíË°®Á§∫„Åô„Çã„É¢„Éº„ÉÄ„É´„Çí‰ΩúÊàê
            const modal = createTestResultModal(filename, fileMethods.length);
            
            let successCount = 0;
            let errorCount = 0;
            let skipCount = 0;
            let testResults = [];
            
            // ÂêÑ„É°„ÇΩ„ÉÉ„Éâ„ÇíÈ†ÜÊ¨°„ÉÜ„Çπ„Éà
            fileMethods.forEach((method, index) => {
                setTimeout(() => {
                    const result = testSingleMethod(method.className, method.name);
                    testResults.push({
                        method: method.name,
                        className: method.className,
                        result: result
                    });
                    
                    // **‰øÆÊ≠£**: „Çπ„Ç≠„ÉÉ„ÉóÂà§ÂÆö„ÇíËøΩÂä†
                    if (result.success) {
                        if (result.message.includes('‚è≠Ô∏è') || result.message.includes('[„Çπ„Ç≠„ÉÉ„Éó]')) {
                            skipCount++;
                        } else {
                            successCount++;
                        }
                    } else {
                        errorCount++;
                    }
                    
                    // „É¢„Éº„ÉÄ„É´„ÅÆÈÄ≤Êçó„ÇíÊõ¥Êñ∞
                    updateTestProgress(modal, index + 1, fileMethods.length, successCount, errorCount, skipCount, testResults);
                    
                }, index * 100); // 100msÈñìÈöî„ÅßÂÆüË°å
            });
        }

        // **Êñ∞Ê©üËÉΩ**: „ÉÜ„Çπ„ÉàÁµêÊûú„É¢„Éº„ÉÄ„É´‰ΩúÊàê
        function createTestResultModal(filename, totalMethods) {
            // Êó¢Â≠ò„ÅÆ„É¢„Éº„ÉÄ„É´„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
            const existingModal = document.getElementById('testResultModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // „Ç™„Éº„Éê„Éº„É¨„Ç§
            const overlay = document.createElement('div');
            overlay.id = 'testResultModal';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.7);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            // „É¢„Éº„ÉÄ„É´Êú¨‰Ωì
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 80%;
                max-height: 80%;
                overflow-y: auto;
                box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                min-width: 600px;
            `;
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 15px;">
                    <h3 style="margin: 0; color: #2c3e50;">üß™ ${filename} - ‰∏ÄÊã¨„ÉÜ„Çπ„ÉàÂÆüË°å</h3>
                    <button onclick="document.getElementById('testResultModal').remove()" 
                            style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">
                        ‚úï Èñâ„Åò„Çã
                    </button>
                </div>
                
                <div id="testProgress" style="margin-bottom: 20px;">
                    <div style="background: #f8f9fa; border-radius: 8px; padding: 15px; text-align: center;">
                        <div style="font-size: 1.2em; margin-bottom: 10px;">üìä „ÉÜ„Çπ„ÉàÈÄ≤Êçó</div>
                        <div style="background: #e9ecef; border-radius: 10px; height: 20px; overflow: hidden; margin-bottom: 10px;">
                            <div id="progressBar" style="background: linear-gradient(90deg, #28a745, #20c997); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        <div id="progressText">0 / ${totalMethods} „É°„ÇΩ„ÉÉ„ÉâÂÆå‰∫Ü</div>
                    </div>
                </div>
                
                <div id="testResults" style="max-height: 400px; overflow-y: auto;">
                    <div style="text-align: center; color: #6c757d; padding: 20px;">
                        „ÉÜ„Çπ„ÉàÂÆüË°å‰∏≠...
                    </div>
                </div>
                
                <!-- **Êñ∞Ê©üËÉΩ**: „Ç≥„Éî„ÉöÁî®ÁµêÊûúË°®Á§∫„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0; color: #333;">üìã „Ç≥„Éî„ÉöÁî®„ÉÜ„Çπ„ÉàÁµêÊûú</h4>
                        <div>
                            <button id="copyResultsBtn" style="
                                background: #007bff; 
                                color: white; 
                                border: none; 
                                padding: 5px 12px; 
                                border-radius: 4px; 
                                cursor: pointer; 
                                font-size: 12px;
                                margin-right: 5px;
                            ">üìã „Ç≥„Éî„Éº</button>
                            <button id="copyErrorsOnlyBtn" style="
                                background: #dc3545; 
                                color: white; 
                                border: none; 
                                padding: 5px 12px; 
                                border-radius: 4px; 
                                cursor: pointer; 
                                font-size: 12px;
                            ">‚ùå „Ç®„É©„Éº„ÅÆ„Åø„Ç≥„Éî„Éº</button>
                        </div>
                    </div>
                    <textarea id="copyableResults" readonly style="
                        width: 100%; 
                        height: 150px; 
                        font-family: 'Courier New', monospace; 
                        font-size: 12px; 
                        border: 1px solid #ddd; 
                        border-radius: 4px; 
                        padding: 10px; 
                        background: #f8f9fa; 
                        resize: vertical;
                        white-space: pre;
                    " placeholder="„ÉÜ„Çπ„ÉàÁµêÊûú„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô..."></textarea>
                </div>
                    `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // **Êñ∞Ê©üËÉΩ**: „Ç≥„Éî„Éº„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºËøΩÂä†
            const copyResultsBtn = modal.querySelector('#copyResultsBtn');
            const copyErrorsOnlyBtn = modal.querySelector('#copyErrorsOnlyBtn');
            const copyableResults = modal.querySelector('#copyableResults');
            
            if (copyResultsBtn && copyableResults) {
                copyResultsBtn.addEventListener('click', () => {
                    copyableResults.select();
                    document.execCommand('copy');
                    
                    // „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØË°®Á§∫
                    const originalText = copyResultsBtn.textContent;
                    copyResultsBtn.textContent = '‚úÖ „Ç≥„Éî„ÉºÂÆå‰∫Ü';
                    copyResultsBtn.style.background = '#28a745';
                    
                    setTimeout(() => {
                        copyResultsBtn.textContent = originalText;
                        copyResultsBtn.style.background = '#007bff';
                    }, 2000);
                });
            }
            
            if (copyErrorsOnlyBtn && copyableResults) {
                copyErrorsOnlyBtn.addEventListener('click', () => {
                    // „Ç®„É©„Éº„ÅÆ„Åø„ÇíÊäΩÂá∫Ôºà‰øÆÊ≠£ÁâàÔºâ
                    const allText = copyableResults.value;
                    const lines = allText.split('\n');
                    let errorOnlyText = `=== „Ç®„É©„ÉºÁµêÊûú„ÅÆ„Åø ===\n`;
                    errorOnlyText += `ÂÆüË°åÊó•ÊôÇ: ${new Date().toLocaleString()}\n\n`;
                    
                    let errorCount = 0;
                    let i = 0;
                    
                    while (i < lines.length) {
                        const line = lines[i];
                        
                        // „Ç®„É©„ÉºË°å„ÇíÁô∫Ë¶ã„Åó„ÅüÂ†¥ÂêàÔºà„É°„ÇΩ„ÉÉ„ÉâÂêç„ÇíÂê´„ÇÄ‚ùåË°å„ÅÆ„Åø„Ç´„Ç¶„É≥„ÉàÔºâ
                        // „Éë„Çø„Éº„É≥: "‚ùå className.methodName (ÊôÇÈñì)" „Åæ„Åü„ÅØ "‚ùå methodName"
                        if (line.includes('‚ùå') && (line.match(/‚ùå\s+\w+\.\w+\s+\(/) || line.match(/‚ùå\s+[\w-]+\.\w+\s+\(/))) {
                            errorCount++;
                            errorOnlyText += line + '\n';
                            
                            // Ê¨°„ÅÆË°å„ÇÇ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ‰∏ÄÈÉ®„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                            let j = i + 1;
                            while (j < lines.length) {
                                const nextLine = lines[j];
                                
                                // Ê¨°„ÅÆ„É°„ÇΩ„ÉÉ„ÉâÁµêÊûúÔºà‚úÖ„ÄÅ‚ùå„ÄÅ‚è≠Ô∏è„ÅßÂßã„Åæ„ÇãÔºâ„Åæ„Åü„ÅØÁ©∫Ë°å„Å´Âà∞ÈÅî„Åó„Åü„ÇâÁµÇ‰∫Ü
                                if ((nextLine.includes('‚úÖ') || nextLine.includes('‚ùå') || nextLine.includes('‚è≠Ô∏è')) && 
                                    (nextLine.match(/[‚úÖ‚ùå‚è≠Ô∏è]\s+\w+/) || nextLine.match(/[‚úÖ‚ùå‚è≠Ô∏è]\s+[\w-]+/)) ||
                                    nextLine.trim() === '' || nextLine.startsWith('===')) {
                                    break;
                                }
                                
                                // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÁ∂ö„Åç„ÇíËøΩÂä†
                                if (nextLine.trim()) {
                                    errorOnlyText += nextLine + '\n';
                                }
                                j++;
                            }
                            
                            errorOnlyText += '\n'; // „Ç®„É©„ÉºÈñì„ÅÆÂå∫Âàá„Çä
                            i = j - 1; // Âá¶ÁêÜÊ∏à„Åø„ÅÆË°å„Çí„Çπ„Ç≠„ÉÉ„Éó
                        }
                        i++;
                    }
                    
                    if (errorCount === 0) {
                        errorOnlyText += '„Ç®„É©„Éº„ÅØÁô∫Áîü„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n';
                    }
                    
                    // ‰∏ÄÊôÇÁöÑ„Å´„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÅÆÂÄ§„ÇíÂ§âÊõ¥„Åó„Å¶„Ç≥„Éî„Éº
                    const originalValue = copyableResults.value;
                    copyableResults.value = errorOnlyText;
                    copyableResults.select();
                    document.execCommand('copy');
                    copyableResults.value = originalValue;
                    
                    // „Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØË°®Á§∫
                    const originalText = copyErrorsOnlyBtn.textContent;
                    if (errorCount > 0) {
                        copyErrorsOnlyBtn.textContent = `‚úÖ ${errorCount}‰ª∂„Ç®„É©„Éº„Ç≥„Éî„ÉºÂÆå‰∫Ü`;
                        copyErrorsOnlyBtn.style.background = '#28a745';
                    } else {
                        copyErrorsOnlyBtn.textContent = '‚úÖ „Ç®„É©„Éº„Å™„Åó';
                        copyErrorsOnlyBtn.style.background = '#17a2b8'; // ÊÉÖÂ†±Ëâ≤ÔºàÈùíÔºâ
                    }
                    
                    setTimeout(() => {
                        copyErrorsOnlyBtn.textContent = originalText;
                        copyErrorsOnlyBtn.style.background = '#dc3545';
                    }, 2000);
                });
            }
            
            return modal;
        }

        // **Êñ∞Ê©üËÉΩ**: „ÉÜ„Çπ„ÉàÈÄ≤ÊçóÊõ¥Êñ∞
        function updateTestProgress(modal, completed, total, successCount, errorCount, skipCount, results) {
            const progressBar = modal.querySelector('#progressBar');
            const progressText = modal.querySelector('#progressText');
            const resultsContainer = modal.querySelector('#testResults');
            const copyableResults = modal.querySelector('#copyableResults');
            
            // ÈÄ≤Êçó„Éê„ÉºÊõ¥Êñ∞
            const percentage = (completed / total) * 100;
            progressBar.style.width = percentage + '%';
            progressText.textContent = `${completed} / ${total} „É°„ÇΩ„ÉÉ„ÉâÂÆå‰∫Ü (‚úÖ ${successCount} ÊàêÂäü, ‚ùå ${errorCount} „Ç®„É©„Éº, ‚è≠Ô∏è ${skipCount} „Çπ„Ç≠„ÉÉ„Éó)`;
            
            // ÁµêÊûú‰∏ÄË¶ßÊõ¥Êñ∞
            let resultsHtml = '';
            let copyableText = `=== „ÉÜ„Çπ„ÉàÁµêÊûú ===\n`;
            copyableText += `ÂÆüË°åÊó•ÊôÇ: ${new Date().toLocaleString()}\n`;
            copyableText += `ÈÄ≤Êçó: ${completed} / ${total} „É°„ÇΩ„ÉÉ„ÉâÂÆå‰∫Ü\n`;
            copyableText += `ÁµêÊûú: ‚úÖ ${successCount} ÊàêÂäü, ‚ùå ${errorCount} „Ç®„É©„Éº, ‚è≠Ô∏è ${skipCount} „Çπ„Ç≠„ÉÉ„Éó\n\n`;
            
            results.forEach(result => {
                // **‰øÆÊ≠£**: „Çπ„Ç≠„ÉÉ„Éó„ÅÆÂ†¥Âêà„ÅÆ„Ç¢„Ç§„Ç≥„É≥„Å®Ëâ≤„ÇíËøΩÂä†
                let statusIcon, statusColor;
                if (result.result.success) {
                    if (result.result.message.includes('‚è≠Ô∏è') || result.result.message.includes('[„Çπ„Ç≠„ÉÉ„Éó]')) {
                        statusIcon = '‚è≠Ô∏è';
                        statusColor = '#ffc107'; // ÈªÑËâ≤ÔºàË≠¶ÂëäËâ≤Ôºâ
                    } else {
                        statusIcon = '‚úÖ';
                        statusColor = '#28a745'; // Á∑ëËâ≤ÔºàÊàêÂäüËâ≤Ôºâ
                    }
                } else {
                    statusIcon = '‚ùå';
                    statusColor = '#dc3545'; // Ëµ§Ëâ≤Ôºà„Ç®„É©„ÉºËâ≤Ôºâ
                }
                
                const executionTime = result.result.executionTime || 'N/A';
                
                resultsHtml += `
                    <div style="border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin-bottom: 8px; border-left: 4px solid ${statusColor};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <div style="font-weight: 600;">${statusIcon} ${result.method}</div>
                            <div style="font-size: 0.8em; color: #6c757d;">${result.className} (${executionTime})</div>
                        </div>
                        <div style="font-size: 0.85em; color: #495057; font-family: monospace; background: #f8f9fa; padding: 6px; border-radius: 4px;">
                            ${result.result.message}
                        </div>
                    </div>
                `;
                
                // „Ç≥„Éî„ÉöÁî®„ÉÜ„Ç≠„Çπ„Éà‰ΩúÊàê
                copyableText += `${statusIcon} ${result.className}.${result.method} (${executionTime})\n`;
                copyableText += `   ${result.result.message}\n\n`;
            });
            
            resultsContainer.innerHTML = resultsHtml;
            
            // **Êñ∞Ê©üËÉΩ**: „Ç≥„Éî„ÉöÁî®„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢Êõ¥Êñ∞
            if (copyableResults) {
                copyableResults.value = copyableText;
            }
        }

        // **Êñ∞Ê©üËÉΩ**: Âçò‰∏Ä„É°„ÇΩ„ÉÉ„Éâ„ÉÜ„Çπ„ÉàÔºàÁµêÊûú„ÅÆ„ÅøËøî„ÅôÔºâ
        function testSingleMethod(className, methodName) {
            try {
                const targetObject = findTargetObject(className);
                
                if (!targetObject) {
                    return {
                        success: false,
                        message: `‚ùå „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà ${className} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`,
                        executionTime: 'N/A'
                    };
                }
                
                if (typeof targetObject[methodName] !== 'function') {
                    return {
                        success: false,
                        message: `‚ùå „É°„ÇΩ„ÉÉ„Éâ ${methodName} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì (type: ${typeof targetObject[methodName]})`,
                        executionTime: 'N/A'
                    };
                }
                
                // „É°„ÇΩ„ÉÉ„ÉâÂÆüË°å
                const startTime = performance.now();
                const result = executeSafeMethod(targetObject, methodName);
                const endTime = performance.now();
                const executionTime = (endTime - startTime).toFixed(2) + 'ms';
                
                // „Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if (typeof result === 'string' && result.startsWith('[„Çπ„Ç≠„ÉÉ„Éó]')) {
                    return {
                        success: true,
                        message: `‚è≠Ô∏è ${result}`,
                        executionTime: executionTime
                    };
                }
                
                return {
                    success: true,
                    message: `‚úÖ ÂÆüË°åÊàêÂäü - Êàª„ÇäÂÄ§: ${formatResult(result)}`,
                    executionTime: executionTime
                };
                
            } catch (error) {
                return {
                    success: false,
                    message: `‚ùå ÂÆüË°å„Ç®„É©„Éº: ${error.message}`,
                    executionTime: 'N/A'
                };
            }
        }

        // **‰øÆÊ≠£**: „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊ§úÁ¥¢„ÅÆÂº∑ÂåñÔºà„Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±‰ªò„ÅçÔºâ
        function findTargetObject(className) {
            console.log(`üîç Searching for object: ${className}`);
            console.log(`  - window.debugMonitor exists:`, !!window.debugMonitor);
            console.log(`  - window.debugMonitor type:`, typeof window.debugMonitor);
            
            // **ÊúÄÂÑ™ÂÖà**: Áõ¥Êé•ÁöÑ„Å™„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÂ≠òÂú®Á¢∫Ë™ç
            if (className === 'DebugMonitor' && window.debugMonitor) {
                console.log(`‚úÖ Found debugMonitor directly (priority check)`);
                return window.debugMonitor;
            }
            
            // 1. Áõ¥Êé•ÁöÑ„Å™„Ç§„É≥„Çπ„Çø„É≥„Çπ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÊ§úÁ¥¢
            const directMappings = {
                'WorkflowEditor': 'workflowEditor',
                'UIManager': 'uiManager', 
                'ConnectionManager': 'connectionManager',
                'NodeManager': 'nodeManager',
                'EventHandlers': 'eventHandlers',
                'DebugMonitor': 'debugMonitor',
                'WorkflowExecutor': 'workflowExecutor',
                'inspector': 'inspector',
                'UniversalMethodInspector': 'inspector'
            };
            
            // **ËøΩÂä†**: „Ç®„Éá„Ç£„Çø„Éº„ÅÆ„Çµ„Éñ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÇÊ§úÁ¥¢ÂØæË±°„Å´ËøΩÂä†
            const editorSubObjects = {
                'ConnectionManager': 'workflowEditor.connectionManager',
                'NodeManager': 'workflowEditor.nodeManager',
                'UIManager': 'workflowEditor.uiManager',
                'EventHandlers': 'workflowEditor.eventHandlers',
                'WorkflowExecutor': 'workflowEditor.workflowExecutor'
            };
            
            // „Ç§„É≥„Çπ„Çø„É≥„Çπ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„Çí‰ΩøÁî®
            const instanceName = directMappings[className];
            if (instanceName && window[instanceName] && typeof window[instanceName] === 'object') {
                console.log(`‚úÖ Found instance object: ${instanceName}`);
                return window[instanceName];
            }
            
            // **ËøΩÂä†**: „Ç®„Éá„Ç£„Çø„Éº„ÅÆ„Çµ„Éñ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊ§úÁ¥¢
            const subObjectPath = editorSubObjects[className];
            if (subObjectPath) {
                try {
                    const pathParts = subObjectPath.split('.');
                    let obj = window;
                    for (const part of pathParts) {
                        obj = obj[part];
                        if (!obj) break;
                    }
                    if (obj && typeof obj === 'object') {
                        console.log(`‚úÖ Found sub-object: ${subObjectPath}`);
                        return obj;
                    }
                } catch (e) {
                    console.log(`‚ùå Failed to access sub-object: ${subObjectPath}`);
                }
            }
            
            // **‰øÆÊ≠£**: „Çà„ÇäÁ¢∫ÂÆü„Å™Áõ¥Êé•Ê§úÁ¥¢
            const directSearchNames = [
                className.toLowerCase(),
                className,
                directMappings[className]
            ].filter(Boolean);
            
            for (const searchName of directSearchNames) {
                if (window[searchName] && typeof window[searchName] === 'object') {
                    console.log(`‚úÖ Found object via direct search: ${searchName}`);
                    return window[searchName];
                }
            }
            
            // **ËøΩÂä†**: ÁâπÂà•„Å™„Ç±„Éº„ÇπÂá¶ÁêÜ
            if (className === 'DebugMonitor' && window.debugMonitor) {
                console.log(`‚úÖ Found debugMonitor via special case handling`);
                return window.debugMonitor;
            }
            
            // **‰øÆÊ≠£**: „Çà„ÇäÁ¢∫ÂÆü„Å™„ÇØ„É©„ÇπÂÆöÁæ©Ê§úÁ¥¢
            console.log(`üîç Checking for class definition: ${className}`);
            console.log(`  - window[${className}] exists:`, typeof window[className]);
            console.log(`  - is function:`, typeof window[className] === 'function');
            
            // 2. „ÇØ„É©„ÇπÂÆöÁæ©„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÄÅ„Éó„É≠„Éà„Çø„Ç§„Éó„É©„ÉÉ„Éë„Éº„Çí‰ΩúÊàê
            let ClassConstructor = null;
            
            // Áõ¥Êé•ÁöÑ„Å™„ÇØ„É©„ÇπÂêçÊ§úÁ¥¢
            if (window[className] && typeof window[className] === 'function') {
                ClassConstructor = window[className];
                console.log(`‚úÖ Found class definition directly: ${className}`);
            }
            
            // **ËøΩÂä†**: „Ç∞„É≠„Éº„Éê„É´Ê§úÁ¥¢„Åß„ÇØ„É©„ÇπÂÆöÁæ©„ÇíÊé¢„Åô
            if (!ClassConstructor) {
                console.log(`üîç Searching globally for class: ${className}`);
                for (const key in window) {
                    try {
                        const obj = window[key];
                        if (typeof obj === 'function' && obj.name === className) {
                            ClassConstructor = obj;
                            console.log(`‚úÖ Found class definition via global search: ${key} -> ${className}`);
                            break;
                        }
                    } catch (e) {
                        // Skip inaccessible properties
                    }
                }
            }
            
            if (ClassConstructor) {
                const prototype = ClassConstructor.prototype;
                
                if (!prototype) {
                    console.log(`‚ùå No prototype found for ${className}`);
                    return null;
                }
                
                console.log(`üîß Creating prototype wrapper for ${className}`);
                console.log(`  - Prototype methods:`, Object.getOwnPropertyNames(prototype).filter(name => 
                    name !== 'constructor' && typeof prototype[name] === 'function'
                ));
                
                // „Éó„É≠„Éà„Çø„Ç§„Éó„É°„ÇΩ„ÉÉ„Éâ„ÇíÁõ¥Êé•ÂÆüË°å„Åß„Åç„Çã„É©„ÉÉ„Éë„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
                const prototypeWrapper = {};
                
                // „Éó„É≠„Éà„Çø„Ç§„Éó„ÅÆ„Åô„Åπ„Å¶„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„Çí„É©„ÉÉ„Éó
                Object.getOwnPropertyNames(prototype).forEach(methodName => {
                    if (methodName !== 'constructor' && typeof prototype[methodName] === 'function') {
                        prototypeWrapper[methodName] = function(...args) {
                            console.log(`üß™ Executing prototype method: ${className}.${methodName}`);
                            try {
                                // **ÊîπÂñÑ**: „Çà„ÇäÂÖÖÂÆü„Åó„Åü„É¢„ÉÉ„ÇØ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩúÊàê
                                const mockContext = {
                                    // Âü∫Êú¨ÁöÑ„Å™„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË®≠ÂÆö
                                    nodes: [],
                                    connections: [],
                                    canvas: document.getElementById('canvas') || document.createElement('div'),
                                    svg: document.getElementById('connections-svg') || document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
                                    selectedNode: null,
                                    isConnecting: false,
                                    // DOMË¶ÅÁ¥†„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅÆ„ÉÄ„Éü„Éº
                                    container: document.createElement('div'),
                                    // WorkflowEditor„ÅÆ„É¢„ÉÉ„ÇØÔºàConnectionManager„ÅåÂøÖË¶Å„Å®„Åô„ÇãÔºâ
                                    editor: {
                                        workflow: { nodes: [], connections: [] },
                                        connectionState: { isConnecting: false }
                                    },
                                    // Âü∫Êú¨ÁöÑ„Å™„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„É¢„ÉÉ„ÇØ
                                    log: () => {},
                                    render: () => {},
                                    update: () => {},
                                    // ResizeObserver„ÅÆ„É¢„ÉÉ„ÇØ
                                    resizeObserver: null
                                };
                                
                                // ÂºïÊï∞„Å™„Åó„ÅßÂÆâÂÖ®„Å´ÂÆüË°å„Åß„Åç„Çã„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„ÅøÂÆüË°å
                                if (args.length === 0) {
                                    const methodLower = methodName.toLowerCase();
                                    const isSafeMethod = (
                                        methodLower.includes('get') || 
                                        methodLower.includes('render') || 
                                        methodLower.includes('update') || 
                                        methodLower.includes('show') ||
                                        methodLower.includes('test') ||
                                        methodLower.includes('check') ||
                                        methodLower.includes('validate') ||
                                        methodLower.includes('debug') ||
                                        methodLower.includes('clear') ||
                                        methodLower.includes('reset') ||
                                        methodLower.includes('init') ||
                                        methodLower.includes('setup') ||
                                        methodLower.includes('handle') ||
                                        methodLower.includes('create') ||
                                        methodLower.includes('destroy')
                                    );
                                    
                                    if (isSafeMethod) {
                                        // „Éó„É≠„Éà„Çø„Ç§„Éó„É°„ÇΩ„ÉÉ„Éâ„Çí„É¢„ÉÉ„ÇØ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅßÂÆüË°å
                                        const result = prototype[methodName].call(mockContext);
                                        return result !== undefined ? result : `[ÂÆüË°åÂÆå‰∫Ü] ${methodName}`;
                                    } else {
                                        return `[„Çπ„Ç≠„ÉÉ„Éó] ${methodName} - ÂÆâÂÖ®„Åß„Å™„ÅÑ„É°„ÇΩ„ÉÉ„Éâ`;
                                    }
                                } else {
                                    return `[„Çπ„Ç≠„ÉÉ„Éó] ${methodName} - ÂºïÊï∞„ÅåÂøÖË¶Å„Å™„É°„ÇΩ„ÉÉ„Éâ`;
                                }
                            } catch (error) {
                                return `[„Ç®„É©„Éº] ${error.message}`;
                            }
                        };
                    }
                });
                
                console.log(`‚úÖ Created prototype wrapper with ${Object.keys(prototypeWrapper).length} methods`);
                return prototypeWrapper;
            }
            
            // 3. „Ç∞„É≠„Éº„Éê„É´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇâÊ§úÁ¥¢
            console.log(`üîç Searching global objects for ${className}`);
            for (const key in window) {
                try {
                    const obj = window[key];
                    if (obj && typeof obj === 'object' && obj.constructor && obj.constructor.name === className) {
                        console.log(`‚úÖ Found via constructor name: ${key}`);
                        return obj;
                    }
                } catch (e) {
                    // „Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Å™„ÅÑ„Éó„É≠„Éë„ÉÜ„Ç£„Çí„Çπ„Ç≠„ÉÉ„Éó
                }
            }
            
            console.log(`‚ùå Object not found: ${className}`);
            return null;
        }

        // **Êñ∞Ê©üËÉΩ**: ÂÆâÂÖ®„Å™„É°„ÇΩ„ÉÉ„ÉâÂÆüË°å
        function executeSafeMethod(targetObject, methodName) {
            const methodStr = targetObject[methodName].toString();
            const paramMatch = methodStr.match(/\\(([^)]*)\\)/);
            const params = paramMatch ? paramMatch[1].split(',').map(p => p.trim()).filter(p => p) : [];
            
            // ÂºïÊï∞„Å™„Åó„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÂ∏∏„Å´ÂÆüË°å
            if (params.length === 0) {
                return targetObject[methodName].apply(targetObject, []);
            }
            
            // ÂÆâÂÖ®„Å™„É°„ÇΩ„ÉÉ„Éâ„Éë„Çø„Éº„É≥ÔºàÂºïÊï∞„Åå„ÅÇ„Å£„Å¶„ÇÇÂÆüË°åÂèØËÉΩÔºâ
            const safePatterns = [
                'get', 'show', 'render', 'display', 'draw', 'paint',
                'update', 'refresh', 'reload', 'reset', 'clear',
                'test', 'check', 'validate', 'verify', 'confirm',
                'debug', 'log', 'print', 'output', 'dump',
                'init', 'initialize', 'setup', 'start', 'begin',
                'stop', 'end', 'finish', 'complete', 'close',
                'count', 'size', 'length', 'empty', 'exists',
                'is', 'has', 'can', 'should', 'will'
            ];
            
            const methodLower = methodName.toLowerCase();
            const isSafeMethod = safePatterns.some(pattern => methodLower.includes(pattern));
            
            if (isSafeMethod) {
                // ÂÆâÂÖ®„Å™„É°„ÇΩ„ÉÉ„Éâ„Åß„ÇÇÂºïÊï∞„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÂü∫Êú¨ÁöÑ„Å™ÂºïÊï∞„ÇíÊèê‰æõ
                const testArgs = params.map((param, index) => {
                    if (param.includes('id') || param.includes('Id')) return 'test-id';
                    if (param.includes('name') || param.includes('Name')) return 'test-name';
                    if (param.includes('type') || param.includes('Type')) return 'test';
                    if (param.includes('index') || param.includes('Index')) return 0;
                    if (param.includes('count') || param.includes('Count')) return 1;
                    if (param.includes('flag') || param.includes('Flag')) return true;
                    return null; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
                });
                
                return targetObject[methodName].apply(targetObject, testArgs);
            }
            
            // „Åù„ÅÆ‰ªñ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„ÅØÂÆüË°å„Çí„Çπ„Ç≠„ÉÉ„Éó
            return `[„Çπ„Ç≠„ÉÉ„Éó] ÂºïÊï∞„ÅåÂøÖË¶Å„Å™„É°„ÇΩ„ÉÉ„Éâ„ÅÆ„Åü„ÇÅÂÆüË°å„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü (ÂºïÊï∞Êï∞: ${params.length})`;
        }

        // **Êñ∞Ê©üËÉΩ**: ÁµêÊûú„Éï„Ç©„Éº„Éû„ÉÉ„Éà
        function formatResult(result) {
            if (result === undefined) return 'undefined';
            if (result === null) return 'null';
            if (typeof result === 'string') return `"${result.substring(0, 100)}${result.length > 100 ? '...' : ''}"`;
            if (typeof result === 'object') {
                const str = JSON.stringify(result);
                return str.substring(0, 100) + (str.length > 100 ? '...' : '');
            }
            return String(result).substring(0, 100);
        }

        

        // **‰øÆÊ≠£**: „ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§„Åó„ÄÅÂÆüÈöõ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰øùË≠∑
        // „ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂÆöÁæ©„ÇíÂâäÈô§ÔºÅÂÆüÈöõ„Å´„É≠„Éº„Éâ„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰∏äÊõ∏„Åç„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´‰øÆÊ≠£
        
        // **„Éá„Éê„ÉÉ„Ç∞**: ÂÆüÈöõ„Å´„É≠„Éº„Éâ„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ≠òÂú®„ÇíÁ¢∫Ë™ç„Åô„ÇãÈñ¢Êï∞
        function checkRealObjects() {
            console.log('üîç Checking for real loaded objects:');
            
            const objectsToCheck = [
                'workflowEditor', 'uiManager', 'connectionManager', 
                'nodeManager', 'eventHandlers', 'debugMonitor', 'workflowExecutor'
            ];
            
            const classesToCheck = [
                'WorkflowEditor', 'UIManager', 'ConnectionManager',
                'NodeManager', 'EventHandlers', 'DebugMonitor', 'WorkflowExecutor'
            ];
            
            objectsToCheck.forEach(name => {
                if (window[name]) {
                    const type = typeof window[name];
                    const constructor = window[name].constructor?.name;
                    const methodCount = Object.getOwnPropertyNames(window[name]).filter(prop => 
                        typeof window[name][prop] === 'function'
                    ).length;
                    console.log(`‚úÖ ${name}: ${type} (${constructor}) - ${methodCount} methods`);
            } else {
                    console.log(`‚ùå ${name}: not found`);
                }
            });
            
            classesToCheck.forEach(className => {
                if (window[className]) {
                    const type = typeof window[className];
                    const prototypeMethodCount = window[className].prototype ? 
                        Object.getOwnPropertyNames(window[className].prototype).filter(prop => 
                            typeof window[className].prototype[prop] === 'function' && prop !== 'constructor'
                        ).length : 0;
                    console.log(`‚úÖ ${className}: ${type} class - ${prototypeMethodCount} prototype methods`);
            } else {
                    console.log(`‚ùå ${className}: class not found`);
                }
            });
        }
        
        // **Êñ∞Ê©üËÉΩ**: ÂÆüÈöõ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Éü„Éã„Éû„É´„ÉÜ„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàê
        function createMinimalTestObjectsIfNeeded() {
            // workflowEditor„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅÊúÄÂ∞èÈôê„ÅÆ„ÉÜ„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
            if (!window.workflowEditor || typeof window.workflowEditor.addNode !== 'function') {
                console.log('‚ö†Ô∏è Real workflowEditor not found, creating minimal test object');
                window.workflowEditor = {
                    addNode: function() { return 'test node added'; },
                    deleteNode: function() { return 'test node deleted'; }
                };
            }
            
            // ‰ªñ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÇÂêåÊßò„Å´„ÉÅ„Çß„ÉÉ„ÇØÔºàÂÆüÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊúÄÂ∞èÈôê‰ΩúÊàêÔºâ
            if (!window.uiManager || typeof window.uiManager.updateUI !== 'function') {
                console.log('‚ö†Ô∏è Real uiManager not found, creating minimal test object');
                window.uiManager = {
                    updateUI: function() { return 'test ui updated'; }
                };
            }
        }

        // **‰øÆÊ≠£**: ÂàùÊúüÂåñ„Å®„Éá„Éê„ÉÉ„Ç∞ÔºàÂÆüÈöõ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰øùË≠∑‰ªò„ÅçÔºâ
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ü§ñ DOMContentLoaded event fired (integrated version)');
            console.log('Inspector available:', typeof window.inspector !== 'undefined');
            
            // **ÈáçË¶Å**: ÂÆüÈöõ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ≠òÂú®Á¢∫Ë™ç
            console.log('='.repeat(60));
            console.log('üîç REAL OBJECT VERIFICATION');
            console.log('='.repeat(60));
            checkRealObjects();
            
            // **„Éá„Éê„ÉÉ„Ç∞**: „É≠„Éº„Éâ„Åï„Çå„Åü„Çπ„ÇØ„É™„Éó„Éà„ÇíÁ¢∫Ë™ç
            console.log('\nüîç Loaded scripts:');
            Array.from(document.scripts).forEach(script => {
                if (script.src) {
                    const filename = script.src.split('/').pop();
                    console.log(`  - ${filename} (${script.src})`);
                }
            });
            
            // **‰øÆÊ≠£**: „ÉÄ„Éü„Éº„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ª£„Çè„Çä„Å´„Éü„Éã„Éû„É´‰øùË≠∑„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
            createMinimalTestObjectsIfNeeded();
            
            if (window.inspector) {
                // **Êñ∞Ê©üËÉΩ**: ‰øùÂ≠ò„Åï„Çå„Åü„É¢„Éº„Éâ„ÇíÂæ©ÂÖÉ„ÄÅ„Å™„Åë„Çå„Å∞„Éá„Éï„Ç©„É´„Éà„É¢„Éº„Éâ„ÇíË®≠ÂÆö
                let savedMode = 'methods'; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
                try {
                    const storedMode = localStorage.getItem('universalMethodInspector_currentMode');
                    if (storedMode && (storedMode === 'methods' || storedMode === 'duplicates')) {
                        savedMode = storedMode;
                        console.log('üíæ Restored mode from localStorage:', savedMode);
                    } else {
                        console.log('üîÑ No valid saved mode found, using default: methods');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to restore mode from localStorage:', error);
                }
                
                window.currentMode = savedMode;
                currentMode = savedMode;
                console.log('üîÑ Current mode set to:', savedMode);
                
                // Ëá™ÂãïÊ§úÂá∫„ÇíÂÆüË°å
                window.inspector.autoDetectGlobalObjects();
                
                // **Êñ∞Ê©üËÉΩ**: Âæ©ÂÖÉ„Åï„Çå„Åü„É¢„Éº„Éâ„Å´Âü∫„Å•„ÅÑ„Å¶UI„ÇíÂàùÊúüÂåñ
                setTimeout(() => {
                    // „Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÂæ©ÂÖÉ„Åï„Çå„Åü„É¢„Éº„Éâ„Å´Âêà„Çè„Åõ„Å¶Êõ¥Êñ∞
                    const methodBtn = document.getElementById('methodMode');
                    const duplicateBtn = document.getElementById('duplicateMode');
                    
                    if (methodBtn) {
                        methodBtn.classList.toggle('active', savedMode === 'methods');
                    }
                    if (duplicateBtn) {
                        duplicateBtn.classList.toggle('active', savedMode === 'duplicates');
                    }
                    
                    // „Çø„Ç§„Éà„É´„ÇíÂæ©ÂÖÉ„Åï„Çå„Åü„É¢„Éº„Éâ„Å´Âêà„Çè„Åõ„Å¶Êõ¥Êñ∞
                    const sectionTitle = document.getElementById('sectionTitle');
                    if (sectionTitle) {
                        if (savedMode === 'methods') {
                            sectionTitle.textContent = 'üîç Detected Methods';
                        } else {
                            sectionTitle.textContent = 'üîç Duplicate Analysis Results';
                        }
                    }
                    
                    // È°û‰ººÂ∫¶„Éï„Ç£„É´„Çø„Éº„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíË®≠ÂÆö
                    const similarityFilter = document.getElementById('similarityFilter');
                    if (similarityFilter) {
                        similarityFilter.style.display = savedMode === 'duplicates' ? 'block' : 'none';
                    }
                    
                    console.log('üéØ UI initialized for mode:', savedMode);
                }, 100);
                
                // ÂàùÊúüË°®Á§∫„ÇíË®≠ÂÆö
                window.inspector.generateDisplay();
                
                // **ÈáçË¶Å**: „Çà„ÇäÈï∑„ÅÑÂæÖÊ©üÊôÇÈñì„ÅßÂÆåÂÖ®„Å™ÂàùÊúüÂåñ„ÇíÂæÖ„Å§
                setTimeout(async () => {
                    console.log('\n' + '='.repeat(60));
                    console.log('üîç STARTING REAL METHOD SCAN');
                    console.log('='.repeat(60));
                    
                    // ÂÜçÂ∫¶ÂÆüÈöõ„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁ¢∫Ë™ç
                    checkRealObjects();
                    
                    console.log('\nüîç Pre-scan verification of window objects:');
                    let realObjectCount = 0;
                    for (const key in window) {
                        try {
                            const obj = window[key];
                            if (obj && typeof obj === 'object' && obj.constructor) {
                                const className = obj.constructor.name;
                                // ÂÆüÈöõ„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                                if (['WorkflowEditor', 'UIManager', 'ConnectionManager', 'NodeManager', 'EventHandlers', 'WorkflowExecutor'].includes(className)) {
                                    const methodCount = Object.getOwnPropertyNames(obj).filter(prop => 
                                        typeof obj[prop] === 'function'
                                    ).length;
                                    console.log(`  ‚úÖ REAL: ${key} (${className}) - ${methodCount} methods`);
                                    realObjectCount++;
                                }
                            }
                        } catch (e) {
                            // Skip inaccessible properties
                        }
                    }
                    
                    console.log(`\nüéØ Found ${realObjectCount} real project objects`);
                    
                    if (realObjectCount === 0) {
                        console.log('‚ö†Ô∏è WARNING: No real project objects found! Script loading may have failed.');
                        console.log('üîç Will proceed with available objects (may include test objects)');
                    }
                    
                    console.log('\nüöÄ Starting method scan...');
                    await window.inspector.scanForMethods();
                }, 3000); // „Åï„Çâ„Å´Èï∑„ÅÑÂæÖÊ©üÊôÇÈñìÔºà3ÁßíÔºâ
                
                window.inspector.showToast('Universal Method Inspector ready - Real object protection enabled', 'success');
            }
        });
    </script>
</body>
</html>