# 翻訳・校閲Webツール実装計画

## プロジェクト概要
- 翻訳および校閲機能を提供するWebツール
- LLMを活用したテキスト処理（Cloudflare Workers経由）
- 4つのモード：日本語→英語翻訳、英語→日本語翻訳、日本語校閲、英語校閲

## 実装構造

### 1. フロントエンド
- **HTML/CSS/JavaScript**で構成されたシンプルなSPA
- モード切替タブ、入力エリア、出力分割表示、実行/初期化ボタン
- ユーザー選択制御（コピー可/不可）機能
- ストリーミング表示対応（progressiveレンダリング）

### 2. バックエンド
- **Cloudflare Worker**を使用したAPI実装
- LLaMA 4などのLLMモデルへのアクセス仲介
- レスポンスの処理とフォーマット調整
- ストリーミングモード対応（SSE: Server-Sent Events）

### 3. LLMインテグレーション
- モードごとに適切なプロンプト設計
- APIリクエスト・レスポンス処理
- ストリーミング対応（workertest.shを参考）

## 実装ステップ

1. **基本HTMLインターフェース構築**
   - モード切替タブ（日英・英日・日本語校閲・英語校閲）
   - 入力/出力エリア
   - ボタン配置とスタイリング
   ```html
   <!DOCTYPE html>
   <html lang="ja">
   <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>LLM翻訳・校閲ツール</title>
     <style>
       /* 基本スタイル */
       body { font-family: 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 20px; max-width: 800px; margin: 0 auto; }
       .tab-container { display: flex; border-bottom: 1px solid #ddd; margin-bottom: 20px; }
       .tab { cursor: pointer; padding: 10px 15px; margin-right: 5px; border: 1px solid #ddd; border-bottom: none; border-radius: 5px 5px 0 0; }
       .tab.active { background: #f0f0f0; font-weight: bold; }
       textarea { width: 100%; min-height: 120px; padding: 10px; margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; }
       .output-container { display: flex; flex-direction: column; gap: 15px; }
       .output-section { padding: 10px; border: 1px solid #ddd; border-radius: 4px; }
       #review { background: #f8f8f8; user-select: none; }
       #final { background: #fff; }
       .btn { padding: 8px 15px; margin-right: 10px; border: none; border-radius: 4px; cursor: pointer; }
       .run-btn { background: #4CAF50; color: white; }
       .reset-btn { background: #f44336; color: white; }
       .loading { display: none; margin-left: 10px; }
     </style>
   </head>
   <body>
     <!-- タブ部分 -->
     <div class="tab-container">
       <div class="tab active" id="tab-jaen">日本語→英語</div>
       <div class="tab" id="tab-enja">英語→日本語</div>
       <div class="tab" id="tab-jajarev">日本語校閲</div>
       <div class="tab" id="tab-enrev">英語校閲</div>
     </div>
     
     <!-- 入力部分 -->
     <textarea id="inputArea" placeholder="ここに入力してください..."></textarea>
     
     <!-- ボタン部分 -->
     <div class="button-container">
       <button class="btn run-btn" id="runBtn">実行</button>
       <button class="btn reset-btn" id="resetBtn">初期化</button>
       <span class="loading" id="loadingIndicator">処理中...</span>
     </div>
     
     <!-- 出力部分 -->
     <div class="output-container">
       <div class="output-section">
         <h3>最終結果（コピー可）</h3>
         <textarea id="final" readonly></textarea>
       </div>
       <div class="output-section">
         <h3>校閲結果（コピー不可）</h3>
         <div id="review"></div>
       </div>
     </div>
     
     <script src="app.js"></script>
   </body>
   </html>
   ```

2. **JavaScript機能実装**
   - モード切替ロジック
   - LLM呼び出し関数（ストリーミング対応）
   - レスポンス処理と分割表示
   - コピー可/不可制御
   ```javascript
   // app.js
   document.addEventListener('DOMContentLoaded', () => {
     // 要素の参照
     const tabs = document.querySelectorAll('.tab');
     const inputArea = document.getElementById('inputArea');
     const finalOutput = document.getElementById('final');
     const reviewOutput = document.getElementById('reviewOutput');
     const runBtn = document.getElementById('runBtn');
     const resetBtn = document.getElementById('resetBtn');
     const loadingIndicator = document.getElementById('loadingIndicator');
     
     // 現在のモード（デフォルト：日本語→英語）
     let currentMode = 'jaen';
     
     // タブ切り替え
     tabs.forEach(tab => {
       tab.addEventListener('click', () => {
         tabs.forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         currentMode = tab.id.replace('tab-', '');
         resetUI();
       });
     });
     
     // コピー禁止制御
     document.getElementById('review').addEventListener('copy', e => {
       e.preventDefault();
     });
     
     // リセットボタン
     resetBtn.addEventListener('click', resetUI);
     
     // 実行ボタン
     runBtn.addEventListener('click', runLLM);
     
     // UI初期化
     function resetUI() {
       inputArea.value = '';
       finalOutput.value = '';
       document.getElementById('review').innerHTML = '';
     }
     
     // LLM実行
     function runLLM() {
       const input = inputArea.value.trim();
       if (!input) {
         alert('テキストを入力してください');
         return;
       }
       
       // UI更新
       loadingIndicator.style.display = 'inline';
       finalOutput.value = '';
       document.getElementById('review').innerHTML = '';
       
       // モードに応じたプロンプト作成
       const messages = createMessages(currentMode, input);
       
       // APIリクエスト
       callLLMAPI(messages);
     }
     
     // モードごとのメッセージ作成
     function createMessages(mode, input) {
       const messagesMap = {
         'jaen': [
           { role: "system", content: "あなたは日本語を正確なビジネス英語に翻訳するプロフェッショナルです。" },
           { role: "user", content: input }
         ],
         'enja': [
           { role: "system", content: "あなたは英語を自然で正確な日本語に翻訳するプロフェッショナルです。" },
           { role: "user", content: input }
         ],
         'jajarev': [
           { role: "system", content: "次の日本語文を校閲してください。どこが直すべき点かを簡潔に解説し、最後に改善済みの文を提示してください。出力は「校閲結果:」から始め、その後「最終案:」で続けてください。" },
           { role: "user", content: input }
         ],
         'enrev': [
           { role: "system", content: "次の英文を校閲してください。どこが直すべき点かを日本語で簡潔に解説し、最後に改善済みの英文を提示してください。出力は「校閲結果:」から始め、その後「最終案:」で続けてください。" },
           { role: "user", content: input }
         ]
       };
       
       return messagesMap[mode] || messagesMap['jaen'];
     }
     
     // LLM API呼び出し（ストリーミング対応）
     function callLLMAPI(messages) {
       // ストリーミングAPIのエンドポイント
       const apiUrl = 'https://nurumayu-worker.skume-bioinfo.workers.dev/';
       
       // リクエストパラメータ
       const requestData = {
         model: "meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
         temperature: 0.7,
         stream: true,
         max_completion_tokens: 800,
         messages: messages
       };
       
       // ストリーミングレスポンス処理用変数
       let fullResponse = '';
       let isConnected = false;
       
       // fetchを使ったストリーミング処理
       fetch(apiUrl, {
         method: 'POST',
         headers: {
           'Content-Type': 'application/json'
         },
         body: JSON.stringify(requestData)
       })
       .then(response => {
         const reader = response.body.getReader();
         const decoder = new TextDecoder();
         let buffer = '';
         
         function processStream({ done, value }) {
           if (done) {
             // ストリーム終了後の処理
             loadingIndicator.style.display = 'none';
             
             // 校閲系モードの場合、結果を分割
             if (currentMode === 'jajarev' || currentMode === 'enrev') {
               processReviewOutput(fullResponse);
             } else {
               // 翻訳モードはそのまま表示
               finalOutput.value = fullResponse;
             }
             return;
           }
           
           // チャンクを処理
           buffer += decoder.decode(value, { stream: true });
           
           // Server-Sent Eventsの形式でデータを解析
           const lines = buffer.split('\\n');
           buffer = lines.pop() || '';
           
           for (const line of lines) {
             if (line.startsWith('data: ')) {
               try {
                 const data = JSON.parse(line.substring(6));
                 if (data.choices && data.choices.length > 0 && 
                     data.choices[0].delta && data.choices[0].delta.content) {
                   const content = data.choices[0].delta.content;
                   fullResponse += content;
                   
                   // リアルタイムで表示（翻訳モード）
                   if (currentMode === 'jaen' || currentMode === 'enja') {
                     finalOutput.value = fullResponse;
                   }
                 }
               } catch (e) {
                 console.error('JSONパースエラー:', e);
               }
             }
           }
           
           // 次のチャンクを処理
           return reader.read().then(processStream);
         }
         
         return reader.read().then(processStream);
       })
       .catch(error => {
         console.error('API呼び出しエラー:', error);
         loadingIndicator.style.display = 'none';
         document.getElementById('review').innerHTML = `<div class="error">エラーが発生しました: ${error.message}</div>`;
       });
     }
     
     // 校閲結果の処理
     function processReviewOutput(text) {
       const reviewPattern = /校閲結果:([\s\S]+?)最終案:([\s\S]+)/;
       const match = text.match(reviewPattern);
       
       if (match) {
         document.getElementById('review').innerHTML = match[1].trim();
         finalOutput.value = match[2].trim();
       } else {
         // パターンに一致しない場合はそのまま表示
         finalOutput.value = text;
       }
     }
   });
   ```

3. **Cloudflare Worker開発**
   - workertest.shの実装を参考にしたWorkerコード
   - ストリーミング対応エンドポイント
   - LLMモデル接続
   ```javascript
   // worker.js
   export default {
     async fetch(request, env) {
       // CORSヘッダー設定
       const corsHeaders = {
         'Access-Control-Allow-Origin': '*',
         'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
         'Access-Control-Allow-Headers': 'Content-Type',
       };
       
       // OPTIONSリクエスト（プリフライト）の処理
       if (request.method === 'OPTIONS') {
         return new Response(null, {
           headers: corsHeaders
         });
       }
       
       // POSTリクエスト以外は拒否
       if (request.method !== 'POST') {
         return new Response('Method Not Allowed', {
           status: 405,
           headers: corsHeaders
         });
       }
       
       try {
         // リクエストボディを解析
         const requestData = await request.json();
         
         // 必須パラメータチェック
         if (!requestData.messages || !Array.isArray(requestData.messages) || requestData.messages.length === 0) {
           return new Response(JSON.stringify({ error: 'Invalid messages parameter' }), {
             status: 400,
             headers: { ...corsHeaders, 'Content-Type': 'application/json' }
           });
         }
         
         // LLMリクエストパラメータ
         const modelParams = {
           model: requestData.model || "meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8",
           messages: requestData.messages,
           temperature: requestData.temperature || 0.7,
           max_tokens: requestData.max_completion_tokens || 800,
           stream: requestData.stream || false
         };
         
         // LLM APIのエンドポイント（実際のエンドポイントに置き換え）
         const llmEndpoint = "https://api.example.com/v1/chat/completions";
         
         // APIキー（環境変数から取得）
         const apiKey = env.API_KEY;
         
         // LLMにリクエスト
         const llmResponse = await fetch(llmEndpoint, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
             'Authorization': `Bearer ${apiKey}`
           },
           body: JSON.stringify(modelParams)
         });
         
         // ストリーミングモード
         if (modelParams.stream) {
           // SSE用のレスポンスヘッダー
           const responseHeaders = {
             ...corsHeaders,
             'Content-Type': 'text/event-stream',
             'Cache-Control': 'no-cache',
             'Connection': 'keep-alive'
           };
           
           // レスポンスをそのまま返す（ストリーミング）
           return new Response(llmResponse.body, {
             headers: responseHeaders
           });
         } else {
           // 通常モード（非ストリーミング）
           const llmData = await llmResponse.json();
           
           return new Response(JSON.stringify({
             answer: llmData.choices[0].message.content
           }), {
             headers: { ...corsHeaders, 'Content-Type': 'application/json' }
           });
         }
       } catch (error) {
         return new Response(JSON.stringify({ error: error.message }), {
           status: 500,
           headers: { ...corsHeaders, 'Content-Type': 'application/json' }
         });
       }
     }
   };
   ```

4. **プロンプトエンジニアリング**
   - 各モードに対する効果的なプロンプト設計
   - 出力フォーマット制御（「校閲結果:」「最終案:」など）
   - 以下は各モードのプロンプト例：
   
   **日本語→英語翻訳**
   ```
   あなたは日本語を正確なビジネス英語に翻訳するプロフェッショナルです。
   ```
   
   **英語→日本語翻訳**
   ```
   あなたは英語を自然で正確な日本語に翻訳するプロフェッショナルです。
   ```
   
   **日本語校閲**
   ```
   次の日本語文を校閲してください。どこが直すべき点かを簡潔に解説し、最後に改善済みの文を提示してください。出力は「校閲結果:」から始め、その後「最終案:」で続けてください。
   ```
   
   **英語校閲**
   ```
   次の英文を校閲してください。どこが直すべき点かを日本語で簡潔に解説し、最後に改善済みの英文を提示してください。出力は「校閲結果:」から始め、その後「最終案:」で続けてください。
   ```

5. **UI/UX改善**
   - レスポンシブデザイン対応
   - ローディング表示（ストリーミング中）
   - エラーメッセージの改善
   - ダークモード対応（オプション）

6. **パフォーマンス最適化**
   - デバウンス/スロットリング
   - キャッシュ対応検討
   - 大量テキスト処理対応

7. **セキュリティ対策**
   - API認証
   - 入力サニタイズ
   - レート制限

## 拡張可能性
- 追加言語サポート（多言語対応）
- カスタムプロンプト設定オプション
- ユーザー設定保存機能
- 履歴機能
- エクスポート機能（PDFなど）
- 音声入力対応

## 技術スタック
- フロントエンド: HTML5, CSS3, Vanilla JavaScript（またはVue.js/React検討）
- バックエンド: Cloudflare Workers
- LLMモデル: LLaMA 4系列（meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8）
- ストリーミング: Server-Sent Events (SSE)

## 注意点
- APIキーの安全な管理
- レート制限の実装
- 出力結果の分割処理の安定性確保
- ユーザーフレンドリーなエラーハンドリング
- ストリーミング処理のブラウザ互換性確認